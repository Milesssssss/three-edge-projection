{"mappings":"ICoCI,EAAU,EAAQ,EAAO,EACzB,EAAO,EACP,EAEA,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SC9BJ,MAAM,EAAa,IAAI,OAEvB,OAAM,UAAoB,EAAA,MAAK,CAE9B,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,GAEP,IAAI,CAAC,WAAA,CAAc,GACnB,IAAI,CAAC,aAAA,CAAgB,CAAC,EACtB,IAAI,CAAC,aAAA,CAAgB,KACrB,IAAI,CAAC,cAAA,CAAiB,KAEtB,IAAI,CAAC,WAAA,CAAc,EACnB,IAAI,CAAC,UAAA,CAAa,EAAE,CACpB,IAAI,CAAC,gBAAA,CAAmB,EACxB,IAAI,CAAC,eAAA,CAAkB,GAEvB,IAAI,CAAC,mBAAA,CAAsB,CAC1B,SAAU,WACV,OAAQ,SACR,MAAO,QACP,GAAI,WACL,EACA,IAAI,CAAC,qBAAA,CAAwB,CAC5B,SAAU,eACV,OAAQ,eACR,MAAO,eACP,GAAI,cACL,CAED,CAEA,eAAgB,CAAI,CAAG,CAItB,OAFA,IAAI,CAAC,WAAA,CAAc,EAEZ,IAAI,AAEZ,CAEA,iBAAkB,CAAM,CAAG,CAI1B,OAFA,IAAI,CAAC,aAAA,CAAgB,EAEd,IAAI,AAEZ,CAEA,eAAgB,CAAW,CAAG,CAI7B,OAFA,IAAI,CAAC,WAAA,CAAc,EAEZ,IAAI,AAEZ,CAEA,KAAM,CAAG,CAAE,CAAM,CAAE,CAAU,CAAE,CAAO,CAAG,CAExC,IAAM,EAAS,IAAI,EAAA,UAAS,CAAG,IAAI,CAAC,OAApC,EAEA,EAAO,OAAA,CAAS,IAAI,CAAC,IAArB,EACA,EAAO,eAAA,CAAiB,eACxB,EAAO,gBAAA,CAAkB,IAAI,CAAC,aAA9B,EACA,EAAO,kBAAA,CAAoB,IAAI,CAAC,eAAhC,EAEA,EAAO,IAAA,CAAM,EAAK,AAAE,IAEnB,IAAI,CAAC,KAAA,CAAO,EAAQ,EAAQ,EAE7B,EAAG,EAAY,EAEhB,CAEA,MAAO,CAAM,CAAE,CAAM,CAAE,CAAO,CAAG,CAEhC,IAAI,CAAC,eAAA,CAAiB,EAAQ,EAAQ,KAAM,KAAM,EAAA,cAAa,EAAI,KAAA,CAAO,EAE3E,CAEA,gBAAiB,CAAM,CAAE,CAAQ,CAAE,CAAY,CAAE,CAAc,CAAE,EAAmB,EAAA,oBAAmB,AAAC,CAAG,CAE1G,IAAM,EAAa,CAClB,aAAc,GAAgB,IAAI,CAAC,mBAAnC,CACA,eAAgB,GAAkB,IAAI,CAAC,qBAAvC,CACA,aAAc,CAAC,CAAE,EACjB,iBAAkB,CACnB,EAEA,OAAO,IAAI,CAAC,cAAA,CAAgB,EAAQ,GAAa,IAAA,CAAM,EAExD,CAEA,eAAgB,CAAM,CAAE,CAAU,CAAG,KAiChC,EA/BJ,IAAM,EAAU,KAAK,SAAA,CAAW,GAIhC,GAAK,EAAW,GAAA,CAAK,GAAW,CAE/B,IAAM,EAAa,EAAW,GAAA,CAAK,GAEnC,GAAK,EAAW,GAAA,GAAQ,EAEvB,OAAO,EAAW,OAFnB,CAIO,GAAK,AAAsB,IAAtB,EAAO,UAAA,CAMlB,MAAM,AAAI,MAET,gHAOH,CAKA,IAAM,EAAS,IAAI,CAAC,gBAApB,GACM,EAAW,EAAO,UAAxB,CAIM,EAAkB,IAAI,CAAC,UAAA,CAAY,EAAQ,GAC/C,IAAA,CAAM,AAAE,IAER,EAAS,EAEF,IAAI,QAAS,CAAE,EAAS,KAE9B,EAAO,UAAU,CAAE,EAAQ,CAAG,CAAE,QAAA,EAAS,OAAA,CAAO,EAEhD,EAAO,WAAA,CAAa,CAAE,KAAM,SAAU,GAAI,EAAQ,WAAA,EAAY,OAAA,CAAO,EAAG,CAAE,EAAQ,CAInF,KAGA,IAAA,CAAM,AAAE,GAAa,IAAI,CAAC,eAAA,CAAiB,EAAQ,QADpD,GA2BD,OAtBA,EACE,KAAA,CAAO,IAAM,CAAA,GACb,IAAA,CAAM,KAED,GAAU,GAEd,IAAI,CAAC,YAAA,CAAc,EAAQ,EAM7B,GAGD,EAAW,GAAA,CAAK,EAAQ,CAEvB,IAAK,EACL,QAAS,CAEV,GAEO,CAER,CAEA,gBAAiB,CAAY,CAAG,CAE/B,IAAM,EAAW,IAAI,EAAA,cAAa,AAE7B,CAAA,EAAa,KAAA,EAEjB,EAAS,QAAA,CAAU,IAAI,EAAA,eAAc,CAAG,EAAa,KAAA,CAAM,KAAA,CAAO,IAInE,IAAM,IAAI,EAAI,EAAG,EAAI,EAAa,UAAA,CAAW,MAAA,CAAQ,IAAO,CAE3D,IAAM,EAAS,EAAa,UAAU,CAAE,EAAG,CACrC,EAAO,EAAO,IAApB,CACM,EAAQ,EAAO,KAArB,CACM,EAAW,EAAO,QAAxB,CAEM,EAAY,IAAI,EAAA,eAAc,CAAG,EAAO,EAEhC,CAAA,UAAT,IAEJ,IAAI,CAAC,uBAAA,CAAyB,EAAW,EAAO,gBAAhD,EAEA,EAAU,UAAA,CAAe,aAAiB,cAAmB,CAAA,GAI9D,EAAS,YAAA,CAAc,EAAM,EAE9B,CAEA,OAAO,CAER,CAEA,wBAAyB,CAAS,CAAE,CAAe,CAAG,CAOrD,GAAK,IAAoB,EAAA,cAAa,CAAI,OAE1C,IAAM,EAAS,IAAI,EAAA,KAAI,CAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAU,KAAA,CAAO,EAAI,EAAI,IAE9C,EAAO,mBAAA,CAAqB,EAAW,GAAI,mBAA3C,GACA,EAAU,MAAA,CAAQ,EAAG,EAAO,CAAA,CAAG,EAAO,CAAA,CAAG,EAAO,CAAhD,CAIF,CAEA,aAAc,CAAG,CAAE,CAAY,CAAG,CAEjC,IAAM,EAAS,IAAI,EAAA,UAAS,CAAG,IAAI,CAAC,OAApC,EAKA,OAJA,EAAO,OAAA,CAAS,IAAI,CAAC,WAArB,EACA,EAAO,eAAA,CAAiB,GACxB,EAAO,kBAAA,CAAoB,IAAI,CAAC,eAAhC,EAEO,IAAI,QAAS,CAAE,EAAS,KAE9B,EAAO,IAAA,CAAM,EAAK,EAAS,KAAA,EAAW,EAEvC,EAED,CAEA,SAAU,CAIT,OAFA,IAAI,CAAC,YAAL,GAEO,IAAI,AAEZ,CAEA,cAAe,CAEd,GAAK,IAAI,CAAC,cAAA,CAAiB,OAAO,IAAI,CAAC,cAAvC,CAEA,IAAM,EAAQ,AAAuB,UAAvB,OAAO,aAA4B,AAA4B,OAA5B,IAAI,CAAC,aAAA,CAAc,IAAA,CAC9D,EAAmB,EAAE,CAsC3B,OApCK,EAEJ,EAAiB,IAAA,CAAM,IAAI,CAAC,YAAA,CAAc,mBAAoB,UAI9D,EAAiB,IAAA,CAAM,IAAI,CAAC,YAAA,CAAc,wBAAyB,SACnE,EAAiB,IAAA,CAAM,IAAI,CAAC,YAAA,CAAc,qBAAsB,iBAIjE,IAAI,CAAC,cAAA,CAAiB,QAAQ,GAAA,CAAK,GACjC,IAAA,CAAM,AAAE,IAER,IAAM,EAAY,CAAS,CAAE,EAAG,CAEzB,GAEN,CAAA,IAAI,CAAC,aAAA,CAAc,UAAA,CAAa,CAAS,CAAE,EAAG,AAAH,EAI5C,IAAM,EAAK,EAAY,QAAvB,GAEM,EAAO,CACZ,sBACA,EACA,GACA,eACA,EAAG,SAAA,CAAW,EAAG,OAAA,CAAS,KAAQ,EAAG,EAAG,WAAA,CAAa,MACrD,CAAC,IAAA,CAAM,KAER,CAAA,IAAI,CAAC,eAAA,CAAkB,IAAI,eAAA,CAAiB,IAAI,KAAM,CAAE,EAAM,EAE/D,GAEM,IAAI,CAAC,cAAZ,AAED,CAEA,WAAY,CAAM,CAAE,CAAQ,CAAG,CAE9B,OAAO,IAAI,CAAC,YAAA,GAAe,IAAA,CAAM,KAEhC,GAAK,IAAI,CAAC,UAAA,CAAW,MAAA,CAAS,IAAI,CAAC,WAAA,CAAc,CAEhD,IAAM,EAAS,IAAI,OAAQ,IAAI,CAAC,eAAhC,CAEA,CAAA,EAAO,UAAA,CAAa,CAAC,EACrB,EAAO,UAAA,CAAa,CAAC,EACrB,EAAO,SAAA,CAAY,EAEnB,EAAO,WAAA,CAAa,CAAE,KAAM,OAAQ,cAAe,IAAI,CAAC,aAApB,AAAkC,GAEtE,EAAO,SAAA,CAAY,SAAW,CAAC,EAE9B,IAAM,EAAU,EAAE,IAAlB,CAEA,OAAS,EAAQ,IAAjB,EAEC,IAAK,SACJ,EAAO,UAAU,CAAE,EAAQ,EAAA,CAAI,CAAC,OAAA,CAAS,GACzC,KAED,KAAK,QACJ,EAAO,UAAU,CAAE,EAAQ,EAAA,CAAI,CAAC,MAAA,CAAQ,GACxC,KAED,SACC,QAAQ,KAAA,CAAO,2CAA6C,EAAQ,IAAA,CAAO,IAE7E,CAED,EAEA,IAAI,CAAC,UAAA,CAAW,IAAA,CAAM,EAEvB,MAEC,IAAI,CAAC,UAAA,CAAW,IAAA,CAAM,SAAW,CAAC,CAAE,CAAC,EAEpC,OAAO,EAAE,SAAA,CAAY,EAAE,SAAA,CAAY,GAAM,CAE1C,GAID,IAAM,EAAS,IAAI,CAAC,UAAU,CAAE,IAAI,CAAC,UAAA,CAAW,MAAA,CAAS,EAAG,CAG5D,OAFA,EAAO,UAAU,CAAE,EAAQ,CAAG,EAC9B,EAAO,SAAA,EAAa,EACb,CAER,EAED,CAEA,aAAc,CAAM,CAAE,CAAM,CAAG,CAE9B,EAAO,SAAA,EAAa,EAAO,UAAU,CAAE,EAAQ,CAC/C,OAAO,EAAO,UAAU,CAAE,EAAQ,CAClC,OAAO,EAAO,UAAU,CAAE,EAAQ,AAEnC,CAEA,OAAQ,CAEP,QAAQ,GAAA,CAAK,cAAe,IAAI,CAAC,UAAA,CAAW,GAAA,CAAK,AAAE,GAAY,EAAO,SAAtE,EAED,CAEA,SAAU,CAET,IAAM,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,UAAA,CAAW,MAAA,CAAQ,EAAG,EAE/C,IAAI,CAAC,UAAU,CAAE,EAAG,CAAC,SAFtB,GAcA,OARA,IAAI,CAAC,UAAA,CAAW,MAAA,CAAS,EAEK,KAAzB,IAAI,CAAC,eAAA,EAET,IAAI,eAAA,CAAiB,IAAI,CAAC,eAF3B,EAMO,IAAI,AAEZ,CAED,CAIA,SAAS,IAER,IAAI,EACA,EAEJ,UAAY,SAAW,CAAC,EAEvB,IAAM,EAAU,EAAE,IAAlB,CAEA,OAAS,EAAQ,IAAjB,EAEC,IAAK,OACJ,EAAgB,EAAQ,aAAxB,CACA,EAAiB,IAAI,QAAS,SAAW,CAAA,EAExC,EAAc,cAAA,CAAiB,SAAW,CAAK,EAG9C,EAAS,CAAE,MAAO,CAAM,EAEzB,EAEA,mBAAoB,EAErB,GACA,KAED,KAAK,SACJ,IAAM,EAAS,EAAQ,MAAvB,CACM,EAAa,EAAQ,UAA3B,CACA,EAAe,IAAA,CAAM,AAAE,IAEtB,IAAM,EAAQ,EAAO,KAArB,CACM,EAAU,IAAI,EAAM,OAA1B,CAEA,GAAI,CAEH,IAAM,EAAW,AA2BtB,SAAyB,CAAK,CAAE,CAAO,CAAE,CAAK,CAAE,CAAU,MAKrD,EACA,EAJJ,IAAM,EAAe,EAAW,YAAhC,CACM,EAAiB,EAAW,cAAlC,CAKM,EAAe,EAAQ,sBAAA,CAAwB,GAErD,GAAK,IAAiB,EAAM,eAAA,CAE3B,EAAgB,IAAI,EAAM,IAA1B,CACA,EAAiB,EAAQ,iBAAA,CAAmB,EAAO,EAAM,UAAA,CAAY,QAE/D,GAAK,IAAiB,EAAM,WAAA,CAElC,EAAgB,IAAI,EAAM,UAA1B,CACA,EAAiB,EAAQ,uBAAA,CAAyB,EAAO,EAAM,UAAA,CAAY,QAI3E,MAAM,AAAI,MAAO,gDAIlB,GAAK,CAAE,EAAe,EAAA,IAAQ,AAAsB,IAAtB,EAAc,GAAA,CAE3C,MAAM,AAAI,MAAO,uCAAyC,EAAe,SAF1E,IAMA,IAAM,EAAW,CAAE,MAAO,KAAM,WAAY,EAAE,AAAC,EAG/C,IAAM,IAAM,KAAiB,EAAe,KAIvC,EACA,EAHJ,IAAM,EAAgB,IAAI,CAAE,CAAc,CAAE,EAAe,CAAE,CAS7D,GAAK,EAAW,YAAA,CAEf,EAAc,CAAY,CAAE,EAAe,CAC3C,EAAY,EAAQ,sBAAA,CAAwB,EAAe,OAErD,CAIN,GAAK,AAAgB,KAFrB,CAAA,EAAc,EAAQ,cAAA,CAAgB,EAAe,CAAK,CAAE,CAAY,CAAE,EAAe,CAAE,CAAA,EAEhE,SAE3B,EAAY,EAAQ,YAAA,CAAc,EAAe,EAElD,CAEA,IAAM,EAAkB,AAwC1B,SAA0B,CAAK,CAAE,CAAO,CAAE,CAAa,CAAE,CAAa,CAAE,CAAa,CAAE,CAAS,EAE/F,IAAM,EAAgB,EAAU,cAAhC,GACM,EAAY,EAAc,UAAhC,GACM,EAAY,EAAY,EACxB,EAAa,EAAY,EAAc,iBAA7C,CACM,EAAW,AAelB,SAA2B,CAAK,CAAE,CAAa,EAE9C,OAAS,GAER,KAAK,aAAc,OAAO,EAAM,UAAb,AACnB,MAAK,UAAW,OAAO,EAAM,OAAb,AAChB,MAAK,WAAY,OAAO,EAAM,QAAb,AACjB,MAAK,WAAY,OAAO,EAAM,QAAb,AACjB,MAAK,WAAY,OAAO,EAAM,QAAb,AACjB,MAAK,YAAa,OAAO,EAAM,SAAb,AAClB,MAAK,YAAa,OAAO,EAAM,SAAb,AAEnB,CAED,EA7BoC,EAAO,GAEpC,EAAM,EAAM,OAAA,CAAS,GAC3B,EAAQ,iCAAA,CAAmC,EAAe,EAAW,EAAU,EAAY,GAC3F,IAAM,EAAQ,IAAI,EAAe,EAAM,OAAA,CAAQ,MAAA,CAAQ,EAAK,GAAY,KAAxE,GAGA,OAFA,EAAM,KAAA,CAAO,GAEN,CACN,KAAM,EACN,MAAO,EACP,SAAU,CACX,CAED,EA3D2C,EAAO,EAAS,EAAe,EAAe,EAAe,EAE/E,CAAA,UAAlB,GAEJ,CAAA,EAAgB,gBAAA,CAAmB,EAAW,gBAF/C,AAAA,EAMA,EAAS,UAAA,CAAW,IAAA,CAAM,EAE3B,CAWA,OARK,IAAiB,EAAM,eAAA,EAE3B,CAAA,EAAS,KAAA,CAAQ,AAUnB,SAAsB,CAAK,CAAE,CAAO,CAAE,CAAa,EAElD,IAAM,EAAW,EAAc,SAA/B,GACM,EAAa,AAAW,EAAX,EACb,EAAa,AAAa,EAAb,EAEb,EAAM,EAAM,OAAA,CAAS,GAC3B,EAAQ,uBAAA,CAAyB,EAAe,EAAY,GAC5D,IAAM,EAAQ,IAAI,YAAa,EAAM,OAAA,CAAQ,MAAA,CAAQ,EAAK,GAAa,KAAvE,GAGA,OAFA,EAAM,KAAA,CAAO,GAEN,CAAE,MAAO,EAAO,SAAU,CAAE,CAEpC,EAvBgC,EAAO,EAAS,EAF/C,EAMA,EAAM,OAAA,CAAS,GAER,CAER,EA/GsC,EAAO,EAAS,IAAI,UAAW,GAAU,GAEpE,EAAU,EAAS,UAAA,CAAW,GAAA,CAAK,AAAE,GAAU,EAAK,KAAA,CAAM,MAAhE,CAEK,CAAA,EAAS,KAAA,EAAQ,EAAQ,IAAA,CAAM,EAAS,KAAA,CAAM,KAAA,CAAM,MAAzD,EAEA,KAAK,WAAA,CAAa,CAAE,KAAM,SAAU,GAAI,EAAQ,EAAZ,CAAgB,SAAA,CAAS,EAAG,EAEjE,CAAE,MAAQ,EAAQ,CAEjB,QAAQ,KAAA,CAAO,GAEf,KAAK,WAAA,CAAa,CAAE,KAAM,QAAS,GAAI,EAAQ,EAAZ,CAAgB,MAAO,EAAM,OAAb,AAAqB,EAEzE,QAAU,CAET,EAAM,OAAA,CAAS,EAEhB,CAED,EAGF,CAED,CA4ID,C,I,E,E,S,E,E,SD1kBA,AAAA,CAAA,EAAA,EAAA,QAAO,AAAP,EAAS,UAAA,CAAW,GAAA,CAAI,EAAG,EAAG,GAE9B,MAAM,EAAS,CACd,aAAc,CAAA,EACd,mBAAoB,CAAA,EACpB,yBAA0B,CAAA,EAC1B,UAAW,CAAA,EACX,eAAgB,GAChB,WAAY,KACX,EAAO,GACR,CACD,EAKA,IAAI,EAAO,KAIX,MAAM,EAAc,CACnB,IAAK,KACL,OAAQ,KACR,MAAO,KACP,KAAM,KACN,KAAM,KACN,MAAO,IACR,EAGM,EAAgB,CACrB,IAAK,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,GACvB,OAAQ,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,IAC1B,MAAO,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,GACzB,KAAM,IAAI,EAAA,OAAM,CAAE,EAAG,GAAI,GACzB,KAAM,IAAI,EAAA,OAAM,CAAE,GAAI,EAAG,GACzB,MAAO,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,EAC1B,EAiIA,SAAU,IAET,IAAM,EAAY,OAAO,WAAA,CAAY,GAArC,GAMA,GAHA,EAAU,cAAA,CAAiB,EAAO,cAAlC,CACA,EAAU,wBAAA,CAA2B,EAAO,wBAA5C,CAEI,EAAO,SAAA,CAAW,CAErB,EAAgB,SAAA,CAAY,6BAE5B,GAAI,CACH,IAAM,EAAU,MAAM,EAAU,mBAAA,CAAoB,EAAO,CAC1D,WAAY,CAAC,EAAS,EAAM,KAC3B,EAAgB,SAAA,CACf,CACC;SAAS,EAAE,EAAK,QAAQ,EAAE,WAAY,AAAA,CAAA,AAAe,IAAf,CAAe,EAAK,OAAA,CAAQ,IAClE;SAAS,EAAE,WAAY,AAAA,CAAA,AAAU,IAAV,CAAU,EAAK,OAAA,CAAQ,IAAI,CAAC,CAFtB,AAGhC,CACD,GAGA,IAAK,GAAM,CAAC,EAAM,EAAS,GAAI,OAAO,OAAA,CAAQ,GAC7C,CAAW,CAAC,EAAK,CAAC,QAAA,CAAS,OAA3B,GACA,CAAW,CAAC,EAAK,CAAC,QAAA,CAAW,CAE/B,CAAE,MAAO,EAAO,CACf,EAAgB,SAAA,CAAY,CAAC,OAAO,EAAE,EAAM,OAAA,CAAQ,CAAC,CACrD,QAAQ,KAAA,CAAM,EACf,CACD,KAAO,CAEN,IAAM,EAAU,EAAU,QAAA,CAAS,EAAO,CACzC,WAAY,CAAC,EAAS,EAAM,KAC3B,EAAgB,SAAA,CACf,CAAC,YAAY,EAAE,EAAK,QAAQ,EAAE,WAAY,AAAA,CAAA,AAAe,IAAf,CAAe,EAAK,OAAA,CAAQ,IACrE;SAAS,EAAE,WAAW,AAAC,CAAA,AAAU,IAAV,CAAU,EAAK,OAAA,CAAQ,IAAI,CAAC,CAD0B,AAEhF,CACD,GAEI,EAAS,EAAQ,IAArB,GACA,KAAO,CAAC,EAAO,IAAA,EACd,EAAS,EAAQ,IAAjB,GACA,MAID,IAAM,EAAU,EAAO,KAAvB,CACA,IAAK,GAAM,CAAC,EAAM,EAAS,GAAI,OAAO,OAAA,CAAQ,GAC7C,CAAW,CAAC,EAAK,CAAC,QAAA,CAAS,OAA3B,GACA,CAAW,CAAC,EAAK,CAAC,QAAA,CAAW,CAE/B,CAEA,IAAM,EAAY,OAAO,WAAA,CAAY,GAAA,GAAQ,CAC7C,CAAA,EAAgB,SAAA,CACf,CACC;YAAY,EAAE,EAAU,OAAA,CAAQ,GAChC;kBAAkB,EAAE,AAAC,CAAA,EAAY,CAAA,EAAG,OAAA,CAAQ,GAC5C;MAAM,EAAE,EAAO,SAAA,CAAY,qBAAuB,aAAa,CAHnD,AAKf,EA7LA,AAEA,iBAEC,EAAkB,SAAS,cAAA,CAAe,UAM1C,AADA,CAAA,EAAW,IAAI,EAAA,aAAY,CAAE,CAAE,UAAW,CAAA,CAAK,EAAA,EACtC,aAAA,CAAc,OAAO,gBAA9B,EACA,EAAS,OAAA,CAAQ,OAAO,UAAA,CAAY,OAAO,WAA3C,EACA,EAAS,aAAA,CANO,SAMgB,GAChC,SAAS,IAAA,CAAK,WAAA,CAAY,EAAS,UAAnC,EAGA,EAAQ,IAAI,EAAA,KAAI,CAGhB,IAAM,EAAQ,IAAI,EAAA,gBAAe,CAAE,SAAU,KAC7C,EAAM,QAAA,CAAS,GAAA,CAAI,EAAG,EAAG,GACzB,EAAM,GAAA,CAAI,GAEV,IAAM,EAAe,IAAI,EAAA,YAAW,CAAE,SAAU,IAChD,EAAM,GAAA,CAAI,GAGV,EAAQ,IAAI,EAAA,KAAI,CAChB,EAAM,GAAA,CAAI,GAEV,IAAM,EAAa,IAAI,EAAA,UAAS,CAChC,EAAW,iBAAA,CAAkB,EAAA,cAAa,EAC1C,IAAM,EAAK,IAAI,EACf,EAAG,cAAA,CAAe,8CAClB,EAAW,cAAA,CAAe,GAC1B,IAAM,EAAO,MAAM,EAAW,SAAA,CAAU,yCACxC,EAAQ,EAAK,KAAb,CAEA,IAAM,EAAgB,IAAI,EAAA,oBAAmB,CAAE,CAC9C,cAAe,CAAA,EACf,oBAAqB,EACrB,mBAAoB,EACpB,QAAS,GACT,YAAa,CAAA,CACd,GAEA,EAAM,QAAA,CAAS,AAAA,IACV,EAAE,QAAA,EACL,CAAA,EAAE,QAAA,CAAW,CADd,CAGD,GAEA,EAAM,iBAAA,CAAkB,CAAA,GAGxB,IAAM,EAAM,IAAI,EAAA,IAAG,CAOnB,IAAK,GAAM,CAAC,EAAM,EAAS,GAN3B,EAAI,aAAA,CAAc,EAAO,CAAA,GACzB,EAAI,SAAA,CAAU,EAAM,QAApB,EACA,EAAM,QAAA,CAAS,cAAA,CAAe,IAC9B,EAAM,GAAA,CAAI,GAGqB,OAAO,OAAA,CAAQ,IAAgB,CAC7D,IAAM,EAAa,IAAI,EAAA,YAAW,CACjC,IAAI,EAAA,cAAa,CACjB,IAAI,EAAA,iBAAgB,CAAE,CACrB,MA0DI,AARQ,CACd,IAAK,SACL,OAAQ,QACR,MAAO,MACP,KAAM,MACN,KAAM,IACN,MAAO,GACR,CACa,CA1DU,EA0DJ,EAAI,EAzDpB,UAAW,CACZ,IAED,EAAW,QAAA,CAAS,IAAA,CAAK,GACzB,EAAM,GAAA,CAAI,GACV,CAAW,CAAC,EAAK,CAAG,CACrB,CAGA,EAAY,IAAI,EAAA,4BAA2B,CAI3C,AADA,CAAA,EAAS,IAAI,EAAA,iBAAgB,CAAE,KAAM,OAAO,UAAA,CAAa,OAAO,WAAA,CAAa,IAAM,IAAnF,EACO,QAAA,CAAS,GAAA,CAAI,GAAI,GAAI,IAC5B,EAAO,sBAAP,GACA,EAAO,MAAA,CAAO,EAAG,EAAG,GAGT,IAAI,EAAA,aAAY,CAAE,EAAQ,EAAS,UAA9C,EAGA,AADA,CAAA,EAAM,IAAI,EAAA,GAAE,AAAZ,EACI,GAAA,CAAI,EAAQ,gBAChB,EAAI,GAAA,CAAI,EAAQ,sBAChB,EAAI,GAAA,CAAI,EAAQ,4BAA4B,QAAA,CAAS,IAAM,EAAO,UAAlE,IACA,EAAI,GAAA,CAAI,EAAQ,iBAAkB,EAAG,GAAI,GAAG,QAAA,CAAS,IAAM,EAAO,UAAlE,IACA,EAAI,GAAA,CAAI,EAAQ,aAChB,EAAI,GAAA,CAAI,EAAQ,cAGhB,IAAM,EAAa,EAAI,SAAA,CAAU,SACjC,IAAK,IAAM,KAAQ,OAAO,IAAA,CAAK,GAC9B,CAAM,CAAC,CAAC,KAAK,EAAE,EAAK,CAAC,CAAC,CAAG,CAAA,EACzB,EAAW,GAAA,CAAI,EAAQ,CAAC,KAAK,EAAE,EAAK,CAAC,EAAE,IAAA,CAAK,GAE7C,EAAW,IAAX,GAEA,EAAO,IAEP,AAsFD,SAAS,IAIR,GAFA,sBAAsB,GAElB,EAAM,CACT,IAAM,EAAM,EAAK,IAAjB,EACI,CAAA,EAAI,IAAA,EACP,CAAA,EAAO,IADR,CAGD,CAKA,IAAK,GAAM,CAAC,EAAM,EAAW,GAF7B,EAAM,OAAA,CAAU,EAAO,YAAvB,CAEiC,OAAO,OAAA,CAAQ,IAC/C,EAAW,OAAA,CAAU,EAAO,kBAAA,EAAsB,CAAM,CAAC,CAAC,KAAK,EAAE,EAAK,CAAC,CAAC,CAGzE,EAAS,MAAA,CAAO,EAAO,EAExB,IAxGC,OAAO,gBAAA,CAAiB,SAAU,WACjC,EAAO,MAAA,CAAS,OAAO,UAAA,CAAa,OAAO,WAA3C,CACA,EAAO,sBAAP,GACA,EAAS,OAAA,CAAQ,OAAO,UAAA,CAAY,OAAO,WAA3C,CACD,EAAG,CAAA,EAEJ","sources":["<anon>","example/sixViewProjection.js","node_modules/three/examples/jsm/loaders/DRACOLoader.js"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire6c98\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire6c98\"] = parcelRequire;\n}\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $8e8b252f320f3b48$var$_taskCache = new WeakMap();\nclass $8e8b252f320f3b48$export$45c25de53be259ac extends (0, $ilwiq.Loader) {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new (0, $ilwiq.FileLoader)(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            this.parse(buffer, onLoad, onError);\n        }, onProgress, onError);\n    }\n    parse(buffer, onLoad, onError) {\n        this.decodeDracoFile(buffer, onLoad, null, null, (0, $ilwiq.SRGBColorSpace)).catch(onError);\n    }\n    decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = (0, $ilwiq.LinearSRGBColorSpace)) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs,\n            vertexColorSpace: vertexColorSpace\n        };\n        return this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        const taskKey = JSON.stringify(taskConfig);\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if ($8e8b252f320f3b48$var$_taskCache.has(buffer)) {\n            const cachedTask = $8e8b252f320f3b48$var$_taskCache.get(buffer);\n            if (cachedTask.key === taskKey) return cachedTask.promise;\n            else if (buffer.byteLength === 0) // Technically, it would be possible to wait for the previous task to complete,\n            // transfer the buffer back, and decode again with the second configuration. That\n            // is complex, and I don't know of any reason to decode a Draco buffer twice in\n            // different ways, so this is left unimplemented.\n            throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n        }\n        //\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        // Obtain a worker and assign a task, and construct a geometry instance\n        // when the task completes.\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve: resolve,\n                    reject: reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig: taskConfig,\n                    buffer: buffer\n                }, [\n                    buffer\n                ]);\n            // this.debug();\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        // Remove task from the task list.\n        // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) this._releaseTask(worker, taskID);\n        });\n        // Cache the task result.\n        $8e8b252f320f3b48$var$_taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new (0, $ilwiq.BufferGeometry)();\n        if (geometryData.index) geometry.setIndex(new (0, $ilwiq.BufferAttribute)(geometryData.index.array, 1));\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const result = geometryData.attributes[i];\n            const name = result.name;\n            const array = result.array;\n            const itemSize = result.itemSize;\n            const attribute = new (0, $ilwiq.BufferAttribute)(array, itemSize);\n            if (name === \"color\") {\n                this._assignVertexColorSpace(attribute, result.vertexColorSpace);\n                attribute.normalized = array instanceof Float32Array === false;\n            }\n            geometry.setAttribute(name, attribute);\n        }\n        return geometry;\n    }\n    _assignVertexColorSpace(attribute, inputColorSpace) {\n        // While .drc files do not specify colorspace, the only 'official' tooling\n        // is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n        // file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n        // to decode geometry, and vertex colors are already Linear-sRGB in there.\n        if (inputColorSpace !== (0, $ilwiq.SRGBColorSpace)) return;\n        const _color = new (0, $ilwiq.Color)();\n        for(let i = 0, il = attribute.count; i < il; i++){\n            _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();\n            attribute.setXYZ(i, _color.r, _color.g, _color.b);\n        }\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new (0, $ilwiq.FileLoader)(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, undefined, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) this.decoderConfig.wasmBinary = libraries[1];\n            const fn = $8e8b252f320f3b48$var$DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker = new Worker(this.workerSourceURL);\n                worker._callbacks = {};\n                worker._taskCosts = {};\n                worker._taskLoad = 0;\n                worker.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker);\n            } else this.workerPool.sort(function(a, b) {\n                return a._taskLoad > b._taskLoad ? -1 : 1;\n            });\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i)this.workerPool[i].terminate();\n        this.workerPool.length = 0;\n        if (this.workerSourceURL !== \"\") URL.revokeObjectURL(this.workerSourceURL);\n        return this;\n    }\n}\n/* WEB WORKER */ function $8e8b252f320f3b48$var$DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve /*, reject*/ ) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        // Module is Promise-like. Wrap before resolving to avoid loop.\n                        resolve({\n                            draco: draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry: geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, array, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(array);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\n        } else throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        // Gather all vertex attributes.\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            // A Draco file may be created with default vertex attributes, whose attribute IDs\n            // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n            // a Draco file may contain a custom set of attributes, identified by known unique\n            // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);\n            if (attributeName === \"color\") attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n            geometry.attributes.push(attributeResult);\n        }\n        // Add index.\n        if (geometryType === draco.TRIANGULAR_MESH) geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array: array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n\n\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $4CEV9 = parcelRequire(\"4CEV9\");\n(0, $ilwiq.Object3D).DEFAULT_UP.set(0, 0, 1);\nconst $6ebc3f7021f12dfe$var$params = {\n    displayModel: true,\n    displayProjections: true,\n    includeIntersectionEdges: false,\n    useWorker: false,\n    angleThreshold: 10,\n    regenerate: ()=>{\n        $6ebc3f7021f12dfe$var$task = $6ebc3f7021f12dfe$var$updateAllViews();\n    }\n};\nlet $6ebc3f7021f12dfe$var$renderer, $6ebc3f7021f12dfe$var$camera, $6ebc3f7021f12dfe$var$scene, $6ebc3f7021f12dfe$var$gui, $6ebc3f7021f12dfe$var$controls;\nlet $6ebc3f7021f12dfe$var$model, $6ebc3f7021f12dfe$var$group;\nlet $6ebc3f7021f12dfe$var$outputContainer;\nlet $6ebc3f7021f12dfe$var$task = null;\nlet $6ebc3f7021f12dfe$var$generator;\n// 存储6个视图的投影\nconst $6ebc3f7021f12dfe$var$projections = {\n    top: null,\n    bottom: null,\n    front: null,\n    back: null,\n    left: null,\n    right: null\n};\n// 视图位置配置\nconst $6ebc3f7021f12dfe$var$viewPositions = {\n    top: new (0, $ilwiq.Vector3)(0, 0, 3),\n    bottom: new (0, $ilwiq.Vector3)(0, 0, -3),\n    front: new (0, $ilwiq.Vector3)(0, 3, 0),\n    back: new (0, $ilwiq.Vector3)(0, -3, 0),\n    left: new (0, $ilwiq.Vector3)(-3, 0, 0),\n    right: new (0, $ilwiq.Vector3)(3, 0, 0)\n};\n$6ebc3f7021f12dfe$var$init();\nasync function $6ebc3f7021f12dfe$var$init() {\n    $6ebc3f7021f12dfe$var$outputContainer = document.getElementById(\"output\");\n    const bgColor = 0xeeeeee;\n    // renderer setup\n    $6ebc3f7021f12dfe$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true\n    });\n    $6ebc3f7021f12dfe$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $6ebc3f7021f12dfe$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $6ebc3f7021f12dfe$var$renderer.setClearColor(bgColor, 1);\n    document.body.appendChild($6ebc3f7021f12dfe$var$renderer.domElement);\n    // scene setup\n    $6ebc3f7021f12dfe$var$scene = new (0, $ilwiq.Scene)();\n    // lights\n    const light = new (0, $ilwiq.DirectionalLight)(0xffffff, 3.5);\n    light.position.set(1, 2, 3);\n    $6ebc3f7021f12dfe$var$scene.add(light);\n    const ambientLight = new (0, $ilwiq.AmbientLight)(0xb0bec5, 0.5);\n    $6ebc3f7021f12dfe$var$scene.add(ambientLight);\n    // load model\n    $6ebc3f7021f12dfe$var$group = new (0, $ilwiq.Group)();\n    $6ebc3f7021f12dfe$var$scene.add($6ebc3f7021f12dfe$var$group);\n    const gltfLoader = new (0, $7lx9d.GLTFLoader)();\n    gltfLoader.setMeshoptDecoder((0, $kp7Te.MeshoptDecoder));\n    const dr = new (0, $8e8b252f320f3b48$export$45c25de53be259ac)();\n    dr.setDecoderPath(\"https://www.gstatic.com/draco/v1/decoders/\");\n    gltfLoader.setDRACOLoader(dr);\n    const gltf = await gltfLoader.loadAsync(\"http://127.0.0.1:8080/SFL-CPD20-Y.glb\");\n    $6ebc3f7021f12dfe$var$model = gltf.scene;\n    const whiteMaterial = new (0, $ilwiq.MeshStandardMaterial)({\n        polygonOffset: true,\n        polygonOffsetFactor: 1,\n        polygonOffsetUnits: 1,\n        opacity: 0.5,\n        transparent: true\n    });\n    $6ebc3f7021f12dfe$var$model.traverse((c)=>{\n        if (c.material) c.material = whiteMaterial;\n    });\n    $6ebc3f7021f12dfe$var$group.updateMatrixWorld(true);\n    // center model\n    const box = new (0, $ilwiq.Box3)();\n    box.setFromObject($6ebc3f7021f12dfe$var$model, true);\n    box.getCenter($6ebc3f7021f12dfe$var$group.position);\n    $6ebc3f7021f12dfe$var$group.position.multiplyScalar(-1);\n    $6ebc3f7021f12dfe$var$group.add($6ebc3f7021f12dfe$var$model);\n    // 初始化6个视图的投影线段\n    for (const [view, position] of Object.entries($6ebc3f7021f12dfe$var$viewPositions)){\n        const projection = new (0, $ilwiq.LineSegments)(new (0, $ilwiq.BufferGeometry)(), new (0, $ilwiq.LineBasicMaterial)({\n            color: $6ebc3f7021f12dfe$var$getViewColor(view),\n            linewidth: 2\n        }));\n        projection.position.copy(position);\n        $6ebc3f7021f12dfe$var$scene.add(projection);\n        $6ebc3f7021f12dfe$var$projections[view] = projection;\n    }\n    // 创建生成器\n    $6ebc3f7021f12dfe$var$generator = new (0, $4CEV9.MultiViewProjectionGenerator)();\n    // camera setup\n    $6ebc3f7021f12dfe$var$camera = new (0, $ilwiq.PerspectiveCamera)(39.5, window.innerWidth / window.innerHeight, 0.01, 500);\n    $6ebc3f7021f12dfe$var$camera.position.set(10, 10, 10);\n    $6ebc3f7021f12dfe$var$camera.updateProjectionMatrix();\n    $6ebc3f7021f12dfe$var$camera.lookAt(0, 0, 0);\n    // controls\n    $6ebc3f7021f12dfe$var$controls = new (0, $5Rd1x.OrbitControls)($6ebc3f7021f12dfe$var$camera, $6ebc3f7021f12dfe$var$renderer.domElement);\n    $6ebc3f7021f12dfe$var$gui = new (0, $jiuw3.GUI)();\n    $6ebc3f7021f12dfe$var$gui.add($6ebc3f7021f12dfe$var$params, \"displayModel\");\n    $6ebc3f7021f12dfe$var$gui.add($6ebc3f7021f12dfe$var$params, \"displayProjections\");\n    $6ebc3f7021f12dfe$var$gui.add($6ebc3f7021f12dfe$var$params, \"includeIntersectionEdges\").onChange(()=>$6ebc3f7021f12dfe$var$params.regenerate());\n    $6ebc3f7021f12dfe$var$gui.add($6ebc3f7021f12dfe$var$params, \"angleThreshold\", 1, 90, 1).onChange(()=>$6ebc3f7021f12dfe$var$params.regenerate());\n    $6ebc3f7021f12dfe$var$gui.add($6ebc3f7021f12dfe$var$params, \"useWorker\");\n    $6ebc3f7021f12dfe$var$gui.add($6ebc3f7021f12dfe$var$params, \"regenerate\");\n    // 添加每个视图的显示控制\n    const viewFolder = $6ebc3f7021f12dfe$var$gui.addFolder(\"Views\");\n    for (const view of Object.keys($6ebc3f7021f12dfe$var$projections)){\n        $6ebc3f7021f12dfe$var$params[`show_${view}`] = true;\n        viewFolder.add($6ebc3f7021f12dfe$var$params, `show_${view}`).name(view);\n    }\n    viewFolder.open();\n    $6ebc3f7021f12dfe$var$task = $6ebc3f7021f12dfe$var$updateAllViews();\n    $6ebc3f7021f12dfe$var$render();\n    window.addEventListener(\"resize\", function() {\n        $6ebc3f7021f12dfe$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $6ebc3f7021f12dfe$var$camera.updateProjectionMatrix();\n        $6ebc3f7021f12dfe$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n}\nfunction $6ebc3f7021f12dfe$var$getViewColor(view) {\n    const colors = {\n        top: 0xff0000,\n        bottom: 0x800000,\n        front: 0x00ff00,\n        back: 0x008000,\n        left: 0x0000ff,\n        right: 0x000080 // 深蓝色\n    };\n    return colors[view] || 0x000000;\n}\nfunction* $6ebc3f7021f12dfe$var$updateAllViews() {\n    const timeStart = window.performance.now();\n    // 更新生成器设置\n    $6ebc3f7021f12dfe$var$generator.angleThreshold = $6ebc3f7021f12dfe$var$params.angleThreshold;\n    $6ebc3f7021f12dfe$var$generator.includeIntersectionEdges = $6ebc3f7021f12dfe$var$params.includeIntersectionEdges;\n    if ($6ebc3f7021f12dfe$var$params.useWorker) {\n        // 使用 Worker 并行生成\n        $6ebc3f7021f12dfe$var$outputContainer.innerText = \"Processing with workers...\";\n        try {\n            const results = yield $6ebc3f7021f12dfe$var$generator.generateWithWorkers($6ebc3f7021f12dfe$var$model, {\n                onProgress: (overall, view, viewProgress)=>{\n                    $6ebc3f7021f12dfe$var$outputContainer.innerText = `Processing with workers...\\n` + `Current: ${view} view - ${parseFloat((viewProgress * 100).toFixed(1))}%\\n` + `Overall: ${parseFloat((overall * 100).toFixed(1))}%`;\n                }\n            });\n            // 更新所有投影\n            for (const [view, geometry] of Object.entries(results)){\n                $6ebc3f7021f12dfe$var$projections[view].geometry.dispose();\n                $6ebc3f7021f12dfe$var$projections[view].geometry = geometry;\n            }\n        } catch (error) {\n            $6ebc3f7021f12dfe$var$outputContainer.innerText = `Error: ${error.message}`;\n            console.error(error);\n        }\n    } else {\n        // 使用生成器逐个生成\n        const genTask = $6ebc3f7021f12dfe$var$generator.generate($6ebc3f7021f12dfe$var$model, {\n            onProgress: (overall, view, viewProgress)=>{\n                $6ebc3f7021f12dfe$var$outputContainer.innerText = `Processing: ${view} view - ${parseFloat((viewProgress * 100).toFixed(1))}%\\n` + `Overall: ${parseFloat((overall * 100).toFixed(1))}%`;\n            }\n        });\n        let result = genTask.next();\n        while(!result.done){\n            result = genTask.next();\n            yield;\n        }\n        // 更新所有投影\n        const results = result.value;\n        for (const [view, geometry] of Object.entries(results)){\n            $6ebc3f7021f12dfe$var$projections[view].geometry.dispose();\n            $6ebc3f7021f12dfe$var$projections[view].geometry = geometry;\n        }\n    }\n    const totalTime = window.performance.now() - timeStart;\n    $6ebc3f7021f12dfe$var$outputContainer.innerText = `Complete!\\n` + `Total time: ${totalTime.toFixed(2)}ms\\n` + `Average per view: ${(totalTime / 6).toFixed(2)}ms\\n` + `Mode: ${$6ebc3f7021f12dfe$var$params.useWorker ? \"Parallel (Workers)\" : \"Sequential\"}`;\n}\nfunction $6ebc3f7021f12dfe$var$render() {\n    requestAnimationFrame($6ebc3f7021f12dfe$var$render);\n    if ($6ebc3f7021f12dfe$var$task) {\n        const res = $6ebc3f7021f12dfe$var$task.next();\n        if (res.done) $6ebc3f7021f12dfe$var$task = null;\n    }\n    // 更新模型和投影的可见性\n    $6ebc3f7021f12dfe$var$model.visible = $6ebc3f7021f12dfe$var$params.displayModel;\n    for (const [view, projection] of Object.entries($6ebc3f7021f12dfe$var$projections))projection.visible = $6ebc3f7021f12dfe$var$params.displayProjections && $6ebc3f7021f12dfe$var$params[`show_${view}`];\n    $6ebc3f7021f12dfe$var$renderer.render($6ebc3f7021f12dfe$var$scene, $6ebc3f7021f12dfe$var$camera);\n}\n\n\n//# sourceMappingURL=sixViewProjection.d7a254c7.js.map\n","import {\n\tBox3,\n\tWebGLRenderer,\n\tScene,\n\tDirectionalLight,\n\tAmbientLight,\n\tGroup,\n\tMeshStandardMaterial,\n\tMeshBasicMaterial,\n\tBufferGeometry,\n\tLineSegments,\n\tLineBasicMaterial,\n\tPerspectiveCamera,\n\tObject3D,\n\tVector3,\n} from 'three';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { MultiViewProjectionGenerator } from '..';\n\nObject3D.DEFAULT_UP.set(0, 0, 1);\n\nconst params = {\n\tdisplayModel: true,\n\tdisplayProjections: true,\n\tincludeIntersectionEdges: false,\n\tuseWorker: false,\n\tangleThreshold: 10,\n\tregenerate: () => {\n\t\ttask = updateAllViews();\n\t},\n};\n\nlet renderer, camera, scene, gui, controls;\nlet model, group;\nlet outputContainer;\nlet task = null;\nlet generator;\n\n// 存储6个视图的投影\nconst projections = {\n\ttop: null,\n\tbottom: null,\n\tfront: null,\n\tback: null,\n\tleft: null,\n\tright: null\n};\n\n// 视图位置配置\nconst viewPositions = {\n\ttop: new Vector3(0, 0, 3),\n\tbottom: new Vector3(0, 0, -3),\n\tfront: new Vector3(0, 3, 0),\n\tback: new Vector3(0, -3, 0),\n\tleft: new Vector3(-3, 0, 0),\n\tright: new Vector3(3, 0, 0)\n};\n\ninit();\n\nasync function init() {\n\n\toutputContainer = document.getElementById('output');\n\n\tconst bgColor = 0xeeeeee;\n\n\t// renderer setup\n\trenderer = new WebGLRenderer({ antialias: true });\n\trenderer.setPixelRatio(window.devicePixelRatio);\n\trenderer.setSize(window.innerWidth, window.innerHeight);\n\trenderer.setClearColor(bgColor, 1);\n\tdocument.body.appendChild(renderer.domElement);\n\n\t// scene setup\n\tscene = new Scene();\n\n\t// lights\n\tconst light = new DirectionalLight(0xffffff, 3.5);\n\tlight.position.set(1, 2, 3);\n\tscene.add(light);\n\n\tconst ambientLight = new AmbientLight(0xb0bec5, 0.5);\n\tscene.add(ambientLight);\n\n\t// load model\n\tgroup = new Group();\n\tscene.add(group);\n\n\tconst gltfLoader = new GLTFLoader();\n\tgltfLoader.setMeshoptDecoder(MeshoptDecoder);\n\tconst dr = new DRACOLoader();\n\tdr.setDecoderPath(\"https://www.gstatic.com/draco/v1/decoders/\");\n\tgltfLoader.setDRACOLoader(dr);\n\tconst gltf = await gltfLoader.loadAsync(\"http://127.0.0.1:8080/SFL-CPD20-Y.glb\");\n\tmodel = gltf.scene;\n\n\tconst whiteMaterial = new MeshStandardMaterial({\n\t\tpolygonOffset: true,\n\t\tpolygonOffsetFactor: 1,\n\t\tpolygonOffsetUnits: 1,\n\t\topacity: 0.5,\n\t\ttransparent: true\n\t});\n\t\n\tmodel.traverse(c => {\n\t\tif (c.material) {\n\t\t\tc.material = whiteMaterial;\n\t\t}\n\t});\n\n\tgroup.updateMatrixWorld(true);\n\n\t// center model\n\tconst box = new Box3();\n\tbox.setFromObject(model, true);\n\tbox.getCenter(group.position);\n\tgroup.position.multiplyScalar(-1);\n\tgroup.add(model);\n\n\t// 初始化6个视图的投影线段\n\tfor (const [view, position] of Object.entries(viewPositions)) {\n\t\tconst projection = new LineSegments(\n\t\t\tnew BufferGeometry(), \n\t\t\tnew LineBasicMaterial({ \n\t\t\t\tcolor: getViewColor(view),\n\t\t\t\tlinewidth: 2\n\t\t\t})\n\t\t);\n\t\tprojection.position.copy(position);\n\t\tscene.add(projection);\n\t\tprojections[view] = projection;\n\t}\n\n\t// 创建生成器\n\tgenerator = new MultiViewProjectionGenerator();\n\n\t// camera setup\n\tcamera = new PerspectiveCamera(39.5, window.innerWidth / window.innerHeight, 0.01, 500);\n\tcamera.position.set(10, 10, 10);\n\tcamera.updateProjectionMatrix();\n\tcamera.lookAt(0, 0, 0);\n\n\t// controls\n\tcontrols = new OrbitControls(camera, renderer.domElement);\n\n\tgui = new GUI();\n\tgui.add(params, 'displayModel');\n\tgui.add(params, 'displayProjections');\n\tgui.add(params, 'includeIntersectionEdges').onChange(() => params.regenerate());\n\tgui.add(params, 'angleThreshold', 1, 90, 1).onChange(() => params.regenerate());\n\tgui.add(params, 'useWorker');\n\tgui.add(params, 'regenerate');\n\n\t// 添加每个视图的显示控制\n\tconst viewFolder = gui.addFolder('Views');\n\tfor (const view of Object.keys(projections)) {\n\t\tparams[`show_${view}`] = true;\n\t\tviewFolder.add(params, `show_${view}`).name(view);\n\t}\n\tviewFolder.open();\n\n\ttask = updateAllViews();\n\n\trender();\n\n\twindow.addEventListener('resize', function () {\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t}, false);\n\n}\n\nfunction getViewColor(view) {\n\tconst colors = {\n\t\ttop: 0xff0000,    // 红色\n\t\tbottom: 0x800000, // 深红色\n\t\tfront: 0x00ff00,  // 绿色\n\t\tback: 0x008000,   // 深绿色\n\t\tleft: 0x0000ff,   // 蓝色\n\t\tright: 0x000080   // 深蓝色\n\t};\n\treturn colors[view] || 0x000000;\n}\n\nfunction* updateAllViews() {\n\n\tconst timeStart = window.performance.now();\n\n\t// 更新生成器设置\n\tgenerator.angleThreshold = params.angleThreshold;\n\tgenerator.includeIntersectionEdges = params.includeIntersectionEdges;\n\n\tif (params.useWorker) {\n\t\t// 使用 Worker 并行生成\n\t\toutputContainer.innerText = 'Processing with workers...';\n\t\t\n\t\ttry {\n\t\t\tconst results = yield generator.generateWithWorkers(model, {\n\t\t\t\tonProgress: (overall, view, viewProgress) => {\n\t\t\t\t\toutputContainer.innerText = \n\t\t\t\t\t\t`Processing with workers...\\n` +\n\t\t\t\t\t\t`Current: ${view} view - ${parseFloat((viewProgress * 100).toFixed(1))}%\\n` +\n\t\t\t\t\t\t`Overall: ${parseFloat((overall * 100).toFixed(1))}%`;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// 更新所有投影\n\t\t\tfor (const [view, geometry] of Object.entries(results)) {\n\t\t\t\tprojections[view].geometry.dispose();\n\t\t\t\tprojections[view].geometry = geometry;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\toutputContainer.innerText = `Error: ${error.message}`;\n\t\t\tconsole.error(error);\n\t\t}\n\t} else {\n\t\t// 使用生成器逐个生成\n\t\tconst genTask = generator.generate(model, {\n\t\t\tonProgress: (overall, view, viewProgress) => {\n\t\t\t\toutputContainer.innerText = \n\t\t\t\t\t`Processing: ${view} view - ${parseFloat((viewProgress * 100).toFixed(1))}%\\n` +\n\t\t\t\t\t`Overall: ${parseFloat((overall * 100).toFixed(1))}%`;\n\t\t\t}\n\t\t});\n\n\t\tlet result = genTask.next();\n\t\twhile (!result.done) {\n\t\t\tresult = genTask.next();\n\t\t\tyield;\n\t\t}\n\n\t\t// 更新所有投影\n\t\tconst results = result.value;\n\t\tfor (const [view, geometry] of Object.entries(results)) {\n\t\t\tprojections[view].geometry.dispose();\n\t\t\tprojections[view].geometry = geometry;\n\t\t}\n\t}\n\n\tconst totalTime = window.performance.now() - timeStart;\n\toutputContainer.innerText = \n\t\t`Complete!\\n` +\n\t\t`Total time: ${totalTime.toFixed(2)}ms\\n` +\n\t\t`Average per view: ${(totalTime / 6).toFixed(2)}ms\\n` +\n\t\t`Mode: ${params.useWorker ? 'Parallel (Workers)' : 'Sequential'}`;\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame(render);\n\n\tif (task) {\n\t\tconst res = task.next();\n\t\tif (res.done) {\n\t\t\ttask = null;\n\t\t}\n\t}\n\n\t// 更新模型和投影的可见性\n\tmodel.visible = params.displayModel;\n\t\n\tfor (const [view, projection] of Object.entries(projections)) {\n\t\tprojection.visible = params.displayProjections && params[`show_${view}`];\n\t}\n\n\trenderer.render(scene, camera);\n\n} ","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tLoader,\n\tLinearSRGBColorSpace,\n\tSRGBColorSpace\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.parse( buffer, onLoad, onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( buffer, onLoad, onError ) {\n\n\t\tthis.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs,\n\t\t\tvertexColorSpace: vertexColorSpace,\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst result = geometryData.attributes[ i ];\n\t\t\tconst name = result.name;\n\t\t\tconst array = result.array;\n\t\t\tconst itemSize = result.itemSize;\n\n\t\t\tconst attribute = new BufferAttribute( array, itemSize );\n\n\t\t\tif ( name === 'color' ) {\n\n\t\t\t\tthis._assignVertexColorSpace( attribute, result.vertexColorSpace );\n\n\t\t\t\tattribute.normalized = ( array instanceof Float32Array ) === false;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( name, attribute );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_assignVertexColorSpace( attribute, inputColorSpace ) {\n\n\t\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n\t\t// file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n\t\t// to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n\t\tif ( inputColorSpace !== SRGBColorSpace ) return;\n\n\t\tconst _color = new Color();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();\n\t\t\tattribute.setXYZ( i, _color.r, _color.g, _color.b );\n\n\t\t}\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\tif ( this.workerSourceURL !== '' ) {\n\n\t\t\tURL.revokeObjectURL( this.workerSourceURL );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, array, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( array );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tconst attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\n\n\t\t\tif ( attributeName === 'color' ) {\n\n\t\t\t\tattributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( attributeResult );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n"],"names":["$6ebc3f7021f12dfe$var$renderer","$6ebc3f7021f12dfe$var$camera","$6ebc3f7021f12dfe$var$scene","$6ebc3f7021f12dfe$var$gui","$6ebc3f7021f12dfe$var$model","$6ebc3f7021f12dfe$var$group","$6ebc3f7021f12dfe$var$outputContainer","$6ebc3f7021f12dfe$var$generator","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$ilwiq","$jiuw3","$5Rd1x","$7lx9d","$8e8b252f320f3b48$var$_taskCache","WeakMap","$8e8b252f320f3b48$export$45c25de53be259ac","Loader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","decodeDracoFile","SRGBColorSpace","catch","callback","attributeIDs","attributeTypes","vertexColorSpace","LinearSRGBColorSpace","taskConfig","useUniqueIDs","decodeGeometry","then","worker","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","message","_createGeometry","geometry","_releaseTask","set","geometryData","BufferGeometry","index","setIndex","BufferAttribute","array","i","attributes","length","result","name","itemSize","attribute","_assignVertexColorSpace","normalized","Float32Array","setAttribute","inputColorSpace","_color","Color","il","count","fromBufferAttribute","convertSRGBToLinear","setXYZ","r","g","b","_loadLibrary","responseType","undefined","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","$8e8b252f320f3b48$var$DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","debug","log","map","dispose","terminate","revokeObjectURL","onModuleLoaded","draco","DracoDecoderModule","decoder","Decoder","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeArrayToMesh","POINT_CLOUD","PointCloud","DecodeArrayToPointCloud","ok","ptr","error_msg","attributeName","attributeID","attributeType","GetAttributeByUniqueId","GetAttributeId","GetAttribute","attributeResult","decodeAttribute","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","Uint32Array","DT_UINT32","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","slice","_free","decodeIndex","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","destroy","buffers","attr","$kp7Te","$4CEV9","Object3D","DEFAULT_UP","$6ebc3f7021f12dfe$var$params","displayModel","displayProjections","includeIntersectionEdges","useWorker","angleThreshold","regenerate","$6ebc3f7021f12dfe$var$task","$6ebc3f7021f12dfe$var$updateAllViews","$6ebc3f7021f12dfe$var$projections","top","bottom","front","back","left","right","$6ebc3f7021f12dfe$var$viewPositions","Vector3","timeStart","performance","now","innerText","results","generateWithWorkers","overall","view","viewProgress","parseFloat","toFixed","Object","entries","genTask","generate","next","done","value","totalTime","$6ebc3f7021f12dfe$var$init","document","getElementById","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","innerWidth","innerHeight","setClearColor","appendChild","domElement","Scene","light","DirectionalLight","add","ambientLight","AmbientLight","Group","gltfLoader","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","dr","setDRACOLoader","gltf","loadAsync","scene","whiteMaterial","MeshStandardMaterial","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","opacity","transparent","traverse","c","material","updateMatrixWorld","box","Box3","setFromObject","getCenter","multiplyScalar","projection","LineSegments","LineBasicMaterial","colors","linewidth","copy","MultiViewProjectionGenerator","PerspectiveCamera","updateProjectionMatrix","lookAt","OrbitControls","GUI","onChange","viewFolder","addFolder","keys","open","$6ebc3f7021f12dfe$var$render","requestAnimationFrame","res","visible","render","addEventListener","aspect"],"version":3,"file":"sixViewProjection.d7a254c7.js.map"}