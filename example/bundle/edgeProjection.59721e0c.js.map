{"mappings":"IGuDI,EAAU,EAAQ,EAAO,EACzB,EAAO,EAAO,EAAY,EAAO,EAAkB,EACnD,EACA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GFxDJ,IAcA,EACA,EAfI,EAAU,CAAC,EAcf,EAbA,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,IAAA,CAAK,GACd,EAAI,EAAG,EAAI,EAAK,MAAA,CAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,GCfA,AAAA,EAAA,SAAA,QAAA,CAA8C,KAAK,KAAA,CAAM,yN,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SEUzD,MAAM,EAAa,IAAI,OAEvB,OAAM,UAAoB,EAAA,MAAK,CAE9B,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,GAEP,IAAI,CAAC,WAAA,CAAc,GACnB,IAAI,CAAC,aAAA,CAAgB,CAAC,EACtB,IAAI,CAAC,aAAA,CAAgB,KACrB,IAAI,CAAC,cAAA,CAAiB,KAEtB,IAAI,CAAC,WAAA,CAAc,EACnB,IAAI,CAAC,UAAA,CAAa,EAAE,CACpB,IAAI,CAAC,gBAAA,CAAmB,EACxB,IAAI,CAAC,eAAA,CAAkB,GAEvB,IAAI,CAAC,mBAAA,CAAsB,CAC1B,SAAU,WACV,OAAQ,SACR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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-c8d478f902f6b426.js","example/edgeProjection.js","node_modules/three/examples/jsm/loaders/DRACOLoader.js","src/worker/ProjectionGeneratorWorker.js","node_modules/@parcel/runtime-js/lib/runtime-7569578f85288298.js","node_modules/@parcel/runtime-js/lib/helpers/get-worker-url.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire6c98\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire6c98\"] = parcelRequire;\n}\nparcelRequire.register(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $18c11f3350a906ea$export$f7ad0328861e2f03, (v) => $18c11f3350a906ea$export$f7ad0328861e2f03 = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = {};\nfunction $18c11f3350a906ea$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$18c11f3350a906ea$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nvar $0d2ed2a407502519$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(JSON.parse('{\"gEVFf\":\"edgeProjection.59721e0c.js\",\"8zbCD\":\"projectionAsync.worker.28971622.js\",\"bGZIs\":\"projectionAsync.worker.9c6d2a59.js\",\"9UJIV\":\"silhouetteProjection.577d2f3c.js\",\"fEfc5\":\"planarIntersection.ac7f7708.js\"}'));\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $7lx9d = parcelRequire(\"7lx9d\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $8e8b252f320f3b48$var$_taskCache = new WeakMap();\nclass $8e8b252f320f3b48$export$45c25de53be259ac extends (0, $ilwiq.Loader) {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new (0, $ilwiq.FileLoader)(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            this.parse(buffer, onLoad, onError);\n        }, onProgress, onError);\n    }\n    parse(buffer, onLoad, onError) {\n        this.decodeDracoFile(buffer, onLoad, null, null, (0, $ilwiq.SRGBColorSpace)).catch(onError);\n    }\n    decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = (0, $ilwiq.LinearSRGBColorSpace)) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs,\n            vertexColorSpace: vertexColorSpace\n        };\n        return this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        const taskKey = JSON.stringify(taskConfig);\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if ($8e8b252f320f3b48$var$_taskCache.has(buffer)) {\n            const cachedTask = $8e8b252f320f3b48$var$_taskCache.get(buffer);\n            if (cachedTask.key === taskKey) return cachedTask.promise;\n            else if (buffer.byteLength === 0) // Technically, it would be possible to wait for the previous task to complete,\n            // transfer the buffer back, and decode again with the second configuration. That\n            // is complex, and I don't know of any reason to decode a Draco buffer twice in\n            // different ways, so this is left unimplemented.\n            throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n        }\n        //\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        // Obtain a worker and assign a task, and construct a geometry instance\n        // when the task completes.\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve: resolve,\n                    reject: reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig: taskConfig,\n                    buffer: buffer\n                }, [\n                    buffer\n                ]);\n            // this.debug();\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        // Remove task from the task list.\n        // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) this._releaseTask(worker, taskID);\n        });\n        // Cache the task result.\n        $8e8b252f320f3b48$var$_taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new (0, $ilwiq.BufferGeometry)();\n        if (geometryData.index) geometry.setIndex(new (0, $ilwiq.BufferAttribute)(geometryData.index.array, 1));\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const result = geometryData.attributes[i];\n            const name = result.name;\n            const array = result.array;\n            const itemSize = result.itemSize;\n            const attribute = new (0, $ilwiq.BufferAttribute)(array, itemSize);\n            if (name === \"color\") {\n                this._assignVertexColorSpace(attribute, result.vertexColorSpace);\n                attribute.normalized = array instanceof Float32Array === false;\n            }\n            geometry.setAttribute(name, attribute);\n        }\n        return geometry;\n    }\n    _assignVertexColorSpace(attribute, inputColorSpace) {\n        // While .drc files do not specify colorspace, the only 'official' tooling\n        // is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n        // file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n        // to decode geometry, and vertex colors are already Linear-sRGB in there.\n        if (inputColorSpace !== (0, $ilwiq.SRGBColorSpace)) return;\n        const _color = new (0, $ilwiq.Color)();\n        for(let i = 0, il = attribute.count; i < il; i++){\n            _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();\n            attribute.setXYZ(i, _color.r, _color.g, _color.b);\n        }\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new (0, $ilwiq.FileLoader)(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, undefined, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) this.decoderConfig.wasmBinary = libraries[1];\n            const fn = $8e8b252f320f3b48$var$DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker = new Worker(this.workerSourceURL);\n                worker._callbacks = {};\n                worker._taskCosts = {};\n                worker._taskLoad = 0;\n                worker.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker);\n            } else this.workerPool.sort(function(a, b) {\n                return a._taskLoad > b._taskLoad ? -1 : 1;\n            });\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i)this.workerPool[i].terminate();\n        this.workerPool.length = 0;\n        if (this.workerSourceURL !== \"\") URL.revokeObjectURL(this.workerSourceURL);\n        return this;\n    }\n}\n/* WEB WORKER */ function $8e8b252f320f3b48$var$DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve /*, reject*/ ) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        // Module is Promise-like. Wrap before resolving to avoid loop.\n                        resolve({\n                            draco: draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry: geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, array, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(array);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\n        } else throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        // Gather all vertex attributes.\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            // A Draco file may be created with default vertex attributes, whose attribute IDs\n            // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n            // a Draco file may contain a custom set of attributes, identified by known unique\n            // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);\n            if (attributeName === \"color\") attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n            geometry.attributes.push(attributeResult);\n        }\n        // Add index.\n        if (geometryType === draco.TRIANGULAR_MESH) geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array: array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n\n\n\nvar $7ePFa = parcelRequire(\"7ePFa\");\n\nvar $kp7Te = parcelRequire(\"kp7Te\");\n\nvar $4CEV9 = parcelRequire(\"4CEV9\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $5c260663d40074f0$var$NAME = \"ProjectionGeneratorWorker\";\nvar $deac5b03489e8ef8$exports = {};\nvar $56b621a6dd25b2cb$exports = {};\n\"use strict\";\n$56b621a6dd25b2cb$exports = function(workerUrl, origin, isESM) {\n    if (origin === self.location.origin) // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n    else {\n        // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n        var source = isESM ? \"import \" + JSON.stringify(workerUrl) + \";\" : \"importScripts(\" + JSON.stringify(workerUrl) + \");\";\n        return URL.createObjectURL(new Blob([\n            source\n        ], {\n            type: \"application/javascript\"\n        }));\n    }\n};\n\n\n\nlet $deac5b03489e8ef8$var$url = new URL((parcelRequire(\"27Lyk\")).resolve(\"8zbCD\"), import.meta.url);\n$deac5b03489e8ef8$exports = $56b621a6dd25b2cb$exports($deac5b03489e8ef8$var$url.toString(), $deac5b03489e8ef8$var$url.origin, true);\n\n\nclass $5c260663d40074f0$export$58847e466a6b9214 {\n    constructor(){\n        this.running = false;\n        this.worker = new Worker($deac5b03489e8ef8$exports);\n        this.worker.onerror = (e)=>{\n            if (e.message) throw new Error(`${$5c260663d40074f0$var$NAME}: Could not create Web Worker with error \"${e.message}\"`);\n            else throw new Error(`${$5c260663d40074f0$var$NAME}: Could not create Web Worker.`);\n        };\n    }\n    generate(geometry, options = {}) {\n        if (this.running) throw new Error(`${$5c260663d40074f0$var$NAME}: Already running job.`);\n        if (this.worker === null) throw new Error(`${$5c260663d40074f0$var$NAME}: Worker has been disposed.`);\n        const { worker: worker } = this;\n        this.running = true;\n        return new Promise((resolve, reject)=>{\n            worker.onerror = (e)=>{\n                reject(new Error(`${$5c260663d40074f0$var$NAME}: ${e.message}`));\n                this.running = false;\n            };\n            worker.onmessage = (e)=>{\n                this.running = false;\n                const { data: data } = e;\n                if (data.error) {\n                    reject(new Error(data.error));\n                    worker.onmessage = null;\n                } else if (data.result) {\n                    const geometry = new (0, $ilwiq.BufferGeometry)();\n                    geometry.setAttribute(\"position\", new (0, $ilwiq.BufferAttribute)(data.result, 3, false));\n                    resolve(geometry);\n                    worker.onmessage = null;\n                } else if (options.onProgress) options.onProgress(data.progress);\n            };\n            const index = geometry.index ? geometry.index.array.slice() : null;\n            const position = geometry.attributes.position.array.slice();\n            const transfer = [\n                position.buffer\n            ];\n            if (index) transfer.push(index.buffer);\n            worker.postMessage({\n                index: index,\n                position: position,\n                options: {\n                    ...options,\n                    onProgress: null,\n                    includedProgressCallback: Boolean(options.onProgress)\n                }\n            }, transfer);\n        });\n    }\n    dispose() {\n        this.worker.terminate();\n        this.worker = null;\n    }\n}\n\n\n\nvar $fNPnQ = parcelRequire(\"fNPnQ\");\n(0, $ilwiq.Object3D).DEFAULT_UP.set(0, 0, 1);\nconst $c9fdec40e3bbb10a$var$params = {\n    displayModel: \"color\",\n    displayEdges: false,\n    displayProjection: true,\n    sortEdges: true,\n    includeIntersectionEdges: false,\n    useWorker: true,\n    projectionDirection: \"top\",\n    rotate: ()=>{\n        $c9fdec40e3bbb10a$var$group.quaternion.random();\n        $c9fdec40e3bbb10a$var$group.position.set(0, 0, 0);\n        $c9fdec40e3bbb10a$var$group.updateMatrixWorld(true);\n        const box = new (0, $ilwiq.Box3)();\n        box.setFromObject($c9fdec40e3bbb10a$var$model, true);\n        box.getCenter($c9fdec40e3bbb10a$var$group.position).multiplyScalar(-1);\n        $c9fdec40e3bbb10a$var$group.position.y = Math.max(0, -box.min.y) + 1;\n    },\n    regenerate: ()=>{\n        $c9fdec40e3bbb10a$var$task = $c9fdec40e3bbb10a$var$updateEdges();\n    }\n};\nconst $c9fdec40e3bbb10a$var$ANGLE_THRESHOLD = 3;\nlet $c9fdec40e3bbb10a$var$renderer, $c9fdec40e3bbb10a$var$camera, $c9fdec40e3bbb10a$var$scene, $c9fdec40e3bbb10a$var$gui, $c9fdec40e3bbb10a$var$controls;\nlet $c9fdec40e3bbb10a$var$lines, $c9fdec40e3bbb10a$var$model, $c9fdec40e3bbb10a$var$projection, $c9fdec40e3bbb10a$var$group, $c9fdec40e3bbb10a$var$shadedWhiteModel, $c9fdec40e3bbb10a$var$whiteModel;\nlet $c9fdec40e3bbb10a$var$outputContainer;\nlet $c9fdec40e3bbb10a$var$worker;\nlet $c9fdec40e3bbb10a$var$task = null;\n$c9fdec40e3bbb10a$var$init();\nasync function $c9fdec40e3bbb10a$var$init() {\n    $c9fdec40e3bbb10a$var$outputContainer = document.getElementById(\"output\");\n    const bgColor = 0xeeeeee;\n    // renderer setup\n    $c9fdec40e3bbb10a$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true\n    });\n    $c9fdec40e3bbb10a$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $c9fdec40e3bbb10a$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $c9fdec40e3bbb10a$var$renderer.setClearColor(bgColor, 1);\n    document.body.appendChild($c9fdec40e3bbb10a$var$renderer.domElement);\n    // scene setup\n    $c9fdec40e3bbb10a$var$scene = new (0, $ilwiq.Scene)();\n    // lights\n    const light = new (0, $ilwiq.DirectionalLight)(0xffffff, 3.5);\n    light.position.set(1, 2, 3);\n    $c9fdec40e3bbb10a$var$scene.add(light);\n    const ambientLight = new (0, $ilwiq.AmbientLight)(0xb0bec5, 0.5);\n    $c9fdec40e3bbb10a$var$scene.add(ambientLight);\n    // load model\n    $c9fdec40e3bbb10a$var$group = new (0, $ilwiq.Group)();\n    $c9fdec40e3bbb10a$var$scene.add($c9fdec40e3bbb10a$var$group);\n    const gltfLoader = await new (0, $7lx9d.GLTFLoader)();\n    gltfLoader.setMeshoptDecoder((0, $kp7Te.MeshoptDecoder));\n    const dr = new (0, $8e8b252f320f3b48$export$45c25de53be259ac)();\n    dr.setDecoderPath(\"https://www.gstatic.com/draco/v1/decoders/\");\n    gltfLoader.setDRACOLoader(dr);\n    const gltf = await gltfLoader.loadAsync(\"http://127.0.0.1:8080/SFL-CPD20-Y.glb\");\n    $c9fdec40e3bbb10a$var$model = gltf.scene;\n    const whiteMaterial = new (0, $ilwiq.MeshStandardMaterial)({\n        polygonOffset: true,\n        polygonOffsetFactor: 1,\n        polygonOffsetUnits: 1\n    });\n    $c9fdec40e3bbb10a$var$shadedWhiteModel = $c9fdec40e3bbb10a$var$model.clone();\n    $c9fdec40e3bbb10a$var$shadedWhiteModel.traverse((c)=>{\n        if (c.material) c.material = whiteMaterial;\n    });\n    const whiteBasicMaterial = new (0, $ilwiq.MeshBasicMaterial)({\n        polygonOffset: true,\n        polygonOffsetFactor: 1,\n        polygonOffsetUnits: 1\n    });\n    $c9fdec40e3bbb10a$var$whiteModel = $c9fdec40e3bbb10a$var$model.clone();\n    $c9fdec40e3bbb10a$var$whiteModel.traverse((c)=>{\n        if (c.material) c.material = whiteBasicMaterial;\n    });\n    $c9fdec40e3bbb10a$var$group.updateMatrixWorld(true);\n    // center model\n    const box = new (0, $ilwiq.Box3)();\n    box.setFromObject($c9fdec40e3bbb10a$var$model, true);\n    box.getCenter($c9fdec40e3bbb10a$var$group.position);\n    $c9fdec40e3bbb10a$var$group.position.y = Math.max(0, -box.min.y) + Math.abs(box.max.y);\n    $c9fdec40e3bbb10a$var$group.add($c9fdec40e3bbb10a$var$model, $c9fdec40e3bbb10a$var$shadedWhiteModel);\n    $c9fdec40e3bbb10a$var$group.position.z = 0;\n    console.log($c9fdec40e3bbb10a$var$group.position);\n    // generate geometry line segments\n    $c9fdec40e3bbb10a$var$lines = new (0, $ilwiq.Group)();\n    $c9fdec40e3bbb10a$var$model.traverse((c)=>{\n        if (c.geometry) {\n            const edges = (0, $fNPnQ.generateEdges)(c.geometry, undefined, $c9fdec40e3bbb10a$var$ANGLE_THRESHOLD);\n            const points = edges.flatMap((line)=>[\n                    line.start,\n                    line.end\n                ]);\n            const geom = new (0, $ilwiq.BufferGeometry)();\n            geom.setFromPoints(points);\n            const geomLines = new (0, $ilwiq.LineSegments)(geom, new (0, $ilwiq.LineBasicMaterial)({\n                color: 0x000000\n            }));\n            geomLines.position.copy(c.position);\n            geomLines.quaternion.copy(c.quaternion);\n            geomLines.scale.copy(c.scale);\n            $c9fdec40e3bbb10a$var$lines.add(geomLines);\n        }\n    });\n    $c9fdec40e3bbb10a$var$group.add($c9fdec40e3bbb10a$var$lines);\n    // create projection display mesh\n    $c9fdec40e3bbb10a$var$projection = new (0, $ilwiq.LineSegments)(new (0, $ilwiq.BufferGeometry)(), new (0, $ilwiq.LineBasicMaterial)({\n        color: 0x000000\n    }));\n    $c9fdec40e3bbb10a$var$scene.add($c9fdec40e3bbb10a$var$projection);\n    // camera setup\n    $c9fdec40e3bbb10a$var$camera = new (0, $ilwiq.PerspectiveCamera)(39.5, window.innerWidth / window.innerHeight, 0.01, 500);\n    $c9fdec40e3bbb10a$var$camera.position.setScalar(3.5);\n    $c9fdec40e3bbb10a$var$camera.updateProjectionMatrix();\n    $c9fdec40e3bbb10a$var$camera.lookAt(0, 0, 0);\n    // controls\n    $c9fdec40e3bbb10a$var$controls = new (0, $5Rd1x.OrbitControls)($c9fdec40e3bbb10a$var$camera, $c9fdec40e3bbb10a$var$renderer.domElement);\n    $c9fdec40e3bbb10a$var$gui = new (0, $jiuw3.GUI)();\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"displayModel\", [\n        \"none\",\n        \"color\",\n        \"shaded white\"\n    ]);\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"displayEdges\");\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"projectionDirection\", [\n        \"top\",\n        \"front\",\n        \"left\",\n        \"back\",\n        \"right\",\n        \"bottom\"\n    ]);\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"displayProjection\");\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"sortEdges\");\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"includeIntersectionEdges\");\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"useWorker\");\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"rotate\");\n    $c9fdec40e3bbb10a$var$gui.add($c9fdec40e3bbb10a$var$params, \"regenerate\");\n    $c9fdec40e3bbb10a$var$worker = new (0, $5c260663d40074f0$export$58847e466a6b9214)();\n    $c9fdec40e3bbb10a$var$task = $c9fdec40e3bbb10a$var$updateEdges();\n    $c9fdec40e3bbb10a$var$render();\n    window.addEventListener(\"resize\", function() {\n        $c9fdec40e3bbb10a$var$camera.aspect = window.innerWidth / window.innerHeight;\n        $c9fdec40e3bbb10a$var$camera.updateProjectionMatrix();\n        $c9fdec40e3bbb10a$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    }, false);\n}\nfunction* $c9fdec40e3bbb10a$var$updateEdges(runTime = 30) {\n    $c9fdec40e3bbb10a$var$outputContainer.innerText = \"processing: --\";\n    // transform and merge geometries to project into a single model\n    let timeStart = window.performance.now();\n    const geometries = [];\n    $c9fdec40e3bbb10a$var$model.updateWorldMatrix(true, true);\n    $c9fdec40e3bbb10a$var$model.traverse((c)=>{\n        if (c.geometry) {\n            const clone = c.geometry.clone();\n            clone.applyMatrix4(c.matrixWorld);\n            // 确保 morphTargetsRelative 属性一致\n            clone.morphTargetsRelative = false;\n            // 删除所有的 morph 属性，因为我们只需要位置信息\n            if (clone.morphAttributes) for(const key in clone.morphAttributes)delete clone.morphAttributes[key];\n            for(const key in clone.attributes)if (key !== \"position\") clone.deleteAttribute(key);\n            geometries.push(clone);\n        }\n    });\n    const mergedGeometry = (0, $7ePFa.mergeGeometries)(geometries, false);\n    const mergeTime = window.performance.now() - timeStart;\n    yield;\n    if ($c9fdec40e3bbb10a$var$params.includeIntersectionEdges) {\n        $c9fdec40e3bbb10a$var$outputContainer.innerText = \"processing: finding edge intersections...\";\n        $c9fdec40e3bbb10a$var$projection.geometry.dispose();\n        $c9fdec40e3bbb10a$var$projection.geometry = new (0, $ilwiq.BufferGeometry)();\n    }\n    // generate the candidate edges\n    timeStart = window.performance.now();\n    let geometry = null;\n    if (!$c9fdec40e3bbb10a$var$params.useWorker) {\n        const generator = new (0, $4CEV9.ProjectionGenerator)();\n        generator.projectionDirection = $c9fdec40e3bbb10a$var$params.projectionDirection;\n        generator.sortEdges = $c9fdec40e3bbb10a$var$params.sortEdges;\n        generator.iterationTime = runTime;\n        generator.angleThreshold = $c9fdec40e3bbb10a$var$ANGLE_THRESHOLD;\n        generator.includeIntersectionEdges = $c9fdec40e3bbb10a$var$params.includeIntersectionEdges;\n        const task = generator.generate(mergedGeometry, {\n            onProgress: (p, data)=>{\n                $c9fdec40e3bbb10a$var$outputContainer.innerText = `processing: ${parseFloat((p * 100).toFixed(2))}%`;\n                if ($c9fdec40e3bbb10a$var$params.displayProjection) {\n                    $c9fdec40e3bbb10a$var$projection.geometry.dispose();\n                    $c9fdec40e3bbb10a$var$projection.geometry = data.getLineGeometry();\n                }\n            }\n        });\n        let result = task.next();\n        while(!result.done){\n            result = task.next();\n            yield;\n        }\n        geometry = result.value;\n    } else {\n        console.log($c9fdec40e3bbb10a$var$params.projectionDirection);\n        $c9fdec40e3bbb10a$var$worker.generate(mergedGeometry, {\n            sortEdges: $c9fdec40e3bbb10a$var$params.sortEdges,\n            projectionDirection: $c9fdec40e3bbb10a$var$params.projectionDirection,\n            includeIntersectionEdges: $c9fdec40e3bbb10a$var$params.includeIntersectionEdges,\n            iterationTime: runTime,\n            angleThreshold: $c9fdec40e3bbb10a$var$ANGLE_THRESHOLD,\n            onProgress: (p)=>{\n                $c9fdec40e3bbb10a$var$outputContainer.innerText = `processing: ${parseFloat((p * 100).toFixed(2))}%`;\n            }\n        }).then((result)=>{\n            geometry = result;\n        });\n        while(geometry === null)yield;\n    }\n    const trimTime = window.performance.now() - timeStart;\n    $c9fdec40e3bbb10a$var$projection.geometry.dispose();\n    $c9fdec40e3bbb10a$var$projection.geometry = geometry;\n    $c9fdec40e3bbb10a$var$outputContainer.innerText = `merge geometry  : ${mergeTime.toFixed(2)}ms\\n` + `edge trimming   : ${trimTime.toFixed(2)}ms`;\n}\nfunction $c9fdec40e3bbb10a$var$render() {\n    requestAnimationFrame($c9fdec40e3bbb10a$var$render);\n    if ($c9fdec40e3bbb10a$var$task) {\n        const res = $c9fdec40e3bbb10a$var$task.next();\n        if (res.done) $c9fdec40e3bbb10a$var$task = null;\n    }\n    $c9fdec40e3bbb10a$var$model.visible = $c9fdec40e3bbb10a$var$params.displayModel === \"color\";\n    $c9fdec40e3bbb10a$var$shadedWhiteModel.visible = $c9fdec40e3bbb10a$var$params.displayModel === \"shaded white\";\n    $c9fdec40e3bbb10a$var$whiteModel.visible = $c9fdec40e3bbb10a$var$params.displayModel === \"white\";\n    $c9fdec40e3bbb10a$var$lines.visible = $c9fdec40e3bbb10a$var$params.displayEdges;\n    $c9fdec40e3bbb10a$var$projection.visible = $c9fdec40e3bbb10a$var$params.displayProjection;\n    $c9fdec40e3bbb10a$var$renderer.render($c9fdec40e3bbb10a$var$scene, $c9fdec40e3bbb10a$var$camera);\n}\n\n\n//# sourceMappingURL=edgeProjection.59721e0c.js.map\n","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"gEVFf\\\":\\\"edgeProjection.59721e0c.js\\\",\\\"8zbCD\\\":\\\"projectionAsync.worker.28971622.js\\\",\\\"bGZIs\\\":\\\"projectionAsync.worker.9c6d2a59.js\\\",\\\"9UJIV\\\":\\\"silhouetteProjection.577d2f3c.js\\\",\\\"fEfc5\\\":\\\"planarIntersection.ac7f7708.js\\\"}\"));","import {\n\tBox3,\n\tWebGLRenderer,\n\tScene,\n\tDirectionalLight,\n\tAmbientLight,\n\tGroup,\n\tMeshStandardMaterial,\n\tMeshBasicMaterial,\n\tBufferGeometry,\n\tLineSegments,\n\tLineBasicMaterial,\n\tPerspectiveCamera,\n\tObject3D,\n} from 'three';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { ProjectionGenerator } from '..';\nimport { ProjectionGeneratorWorker } from '../src/worker/ProjectionGeneratorWorker.js';\nimport { generateEdges } from '../src/utils/generateEdges.js';\n\nObject3D.DEFAULT_UP.set(0, 0, 1);\n\nconst params = {\n\tdisplayModel: 'color',\n\tdisplayEdges: false,\n\tdisplayProjection: true,\n\tsortEdges: true,\n\tincludeIntersectionEdges: false,\n\tuseWorker: true,\n\tprojectionDirection: 'top',\n\trotate: () => {\n\n\t\tgroup.quaternion.random();\n\t\tgroup.position.set(0, 0, 0);\n\t\tgroup.updateMatrixWorld(true);\n\n\t\tconst box = new Box3();\n\t\tbox.setFromObject(model, true);\n\t\tbox.getCenter(group.position).multiplyScalar(- 1);\n\t\tgroup.position.y = Math.max(0, - box.min.y) + 1;\n\n\t},\n\tregenerate: () => {\n\n\t\ttask = updateEdges();\n\n\t},\n};\n\nconst ANGLE_THRESHOLD = 3;\nlet renderer, camera, scene, gui, controls;\nlet lines, model, projection, group, shadedWhiteModel, whiteModel;\nlet outputContainer;\nlet worker;\nlet task = null;\n\ninit();\n\nasync function init() {\n\n\toutputContainer = document.getElementById('output');\n\n\tconst bgColor = 0xeeeeee;\n\n\t// renderer setup\n\trenderer = new WebGLRenderer({ antialias: true });\n\trenderer.setPixelRatio(window.devicePixelRatio);\n\trenderer.setSize(window.innerWidth, window.innerHeight);\n\trenderer.setClearColor(bgColor, 1);\n\tdocument.body.appendChild(renderer.domElement);\n\n\t// scene setup\n\tscene = new Scene();\n\n\t// lights\n\tconst light = new DirectionalLight(0xffffff, 3.5);\n\tlight.position.set(1, 2, 3);\n\tscene.add(light);\n\n\tconst ambientLight = new AmbientLight(0xb0bec5, 0.5);\n\tscene.add(ambientLight);\n\n\t// load model\n\tgroup = new Group();\n\tscene.add(group);\n\n\tconst gltfLoader = await new GLTFLoader()\n\tgltfLoader.setMeshoptDecoder(MeshoptDecoder)\n\tconst dr = new DRACOLoader()\n\tdr.setDecoderPath(\"https://www.gstatic.com/draco/v1/decoders/\")\n\tgltfLoader.setDRACOLoader(dr)\n\tconst gltf = await gltfLoader.loadAsync(\"http://127.0.0.1:8080/SFL-CPD20-Y.glb\");\n\tmodel = gltf.scene;\n\n\tconst whiteMaterial = new MeshStandardMaterial({\n\t\tpolygonOffset: true,\n\t\tpolygonOffsetFactor: 1,\n\t\tpolygonOffsetUnits: 1,\n\t});\n\tshadedWhiteModel = model.clone();\n\tshadedWhiteModel.traverse(c => {\n\n\t\tif (c.material) {\n\n\t\t\tc.material = whiteMaterial;\n\n\t\t}\n\n\t});\n\n\tconst whiteBasicMaterial = new MeshBasicMaterial({\n\t\tpolygonOffset: true,\n\t\tpolygonOffsetFactor: 1,\n\t\tpolygonOffsetUnits: 1,\n\t});\n\twhiteModel = model.clone();\n\twhiteModel.traverse(c => {\n\n\t\tif (c.material) {\n\n\t\t\tc.material = whiteBasicMaterial;\n\n\t\t}\n\n\t});\n\n\tgroup.updateMatrixWorld(true);\n\n\t// center model\n\tconst box = new Box3();\n\tbox.setFromObject(model, true);\n\tbox.getCenter(group.position);\n\tgroup.position.y = Math.max(0, - box.min.y) + Math.abs(box.max.y);\n\tgroup.add(model, shadedWhiteModel);\n\tgroup.position.z= 0\n\tconsole.log(group.position);\n\n\t// generate geometry line segments\n\tlines = new Group();\n\tmodel.traverse(c => {\n\n\t\tif (c.geometry) {\n\n\t\t\tconst edges = generateEdges(c.geometry, undefined, ANGLE_THRESHOLD);\n\t\t\tconst points = edges.flatMap(line => [line.start, line.end]);\n\t\t\tconst geom = new BufferGeometry();\n\t\t\tgeom.setFromPoints(points);\n\n\t\t\tconst geomLines = new LineSegments(geom, new LineBasicMaterial({ color: 0x000000 }));\n\t\t\tgeomLines.position.copy(c.position);\n\t\t\tgeomLines.quaternion.copy(c.quaternion);\n\t\t\tgeomLines.scale.copy(c.scale);\n\t\t\tlines.add(geomLines);\n\n\t\t}\n\n\t});\n\tgroup.add(lines);\n\n\t// create projection display mesh\n\tprojection = new LineSegments(new BufferGeometry(), new LineBasicMaterial({\n\t\tcolor: 0x000000\n\t}));\n\tscene.add(projection);\n\n\t// camera setup\n\tcamera = new PerspectiveCamera(39.5, window.innerWidth / window.innerHeight, 0.01, 500);\n\tcamera.position.setScalar(3.5);\n\tcamera.updateProjectionMatrix();\n\tcamera.lookAt(0, 0, 0);\n\n\t// controls\n\tcontrols = new OrbitControls(camera, renderer.domElement);\n\n\tgui = new GUI();\n\tgui.add(params, 'displayModel', [\n\t\t'none',\n\t\t'color',\n\t\t'shaded white',\n\t\t// 'white',\n\t]);\n\tgui.add( params, 'displayEdges' );\n\tgui.add( params, 'projectionDirection', [\n\t\t'top',\n\t\t'front',\n\t\t'left',\n\t\t'back',\n\t\t'right',\n\t\t'bottom',\n\t] );\n\tgui.add(params, 'displayProjection');\n\tgui.add(params, 'sortEdges');\n\tgui.add(params, 'includeIntersectionEdges');\n\tgui.add(params, 'useWorker');\n\tgui.add(params, 'rotate');\n\tgui.add(params, 'regenerate');\n\n\tworker = new ProjectionGeneratorWorker();\n\n\ttask = updateEdges();\n\n\trender();\n\n\twindow.addEventListener('resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\n\t}, false);\n\n}\n\nfunction* updateEdges(runTime = 30) {\n\n\toutputContainer.innerText = 'processing: --';\n\n\t// transform and merge geometries to project into a single model\n\tlet timeStart = window.performance.now();\n\tconst geometries = [];\n\tmodel.updateWorldMatrix(true, true);\n\tmodel.traverse(c => {\n\n\t\tif (c.geometry) {\n\n\t\t\tconst clone = c.geometry.clone();\n\t\t\tclone.applyMatrix4(c.matrixWorld);\n\n\t\t\t// 确保 morphTargetsRelative 属性一致\n\t\t\tclone.morphTargetsRelative = false;\n\n\t\t\t// 删除所有的 morph 属性，因为我们只需要位置信息\n\t\t\tif (clone.morphAttributes) {\n\t\t\t\tfor (const key in clone.morphAttributes) {\n\t\t\t\t\tdelete clone.morphAttributes[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const key in clone.attributes) {\n\n\t\t\t\tif (key !== 'position') {\n\n\t\t\t\t\tclone.deleteAttribute(key);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometries.push(clone);\n\n\t\t}\n\n\t});\n\tconst mergedGeometry = mergeGeometries(geometries, false);\n\tconst mergeTime = window.performance.now() - timeStart;\n\n\tyield;\n\n\tif (params.includeIntersectionEdges) {\n\n\t\toutputContainer.innerText = 'processing: finding edge intersections...';\n\t\tprojection.geometry.dispose();\n\t\tprojection.geometry = new BufferGeometry();\n\n\t}\n\n\t// generate the candidate edges\n\ttimeStart = window.performance.now();\n\n\tlet geometry = null;\n\tif (!params.useWorker) {\n\n\t\tconst generator = new ProjectionGenerator();\n\t\tgenerator.projectionDirection = params.projectionDirection;\n\t\tgenerator.sortEdges = params.sortEdges;\n\t\tgenerator.iterationTime = runTime;\n\t\tgenerator.angleThreshold = ANGLE_THRESHOLD;\n\t\tgenerator.includeIntersectionEdges = params.includeIntersectionEdges;\n\n\t\tconst task = generator.generate(mergedGeometry, {\n\n\t\t\tonProgress: (p, data) => {\n\n\t\t\t\toutputContainer.innerText = `processing: ${parseFloat((p * 100).toFixed(2))}%`;\n\t\t\t\tif (params.displayProjection) {\n\n\t\t\t\t\tprojection.geometry.dispose();\n\t\t\t\t\tprojection.geometry = data.getLineGeometry();\n\n\t\t\t\t}\n\n\n\t\t\t},\n\n\t\t});\n\n\t\tlet result = task.next();\n\t\twhile (!result.done) {\n\n\t\t\tresult = task.next();\n\t\t\tyield;\n\n\t\t}\n\n\t\tgeometry = result.value;\n\n\t} else {\n\n\t\tconsole.log(params.projectionDirection);\n\t\tworker\n\t\t\t.generate(mergedGeometry, {\n\t\t\t\tsortEdges: params.sortEdges,\n\t\t\t\tprojectionDirection: params.projectionDirection,\n\t\t\t\tincludeIntersectionEdges: params.includeIntersectionEdges,\n\t\t\t\titerationTime: runTime,\n\t\t\t\tangleThreshold: ANGLE_THRESHOLD,\n\t\t\t\tonProgress: p => {\n\n\t\t\t\t\toutputContainer.innerText = `processing: ${parseFloat((p * 100).toFixed(2))}%`;\n\n\t\t\t\t},\n\t\t\t})\n\t\t\t.then(result => {\n\n\t\t\t\tgeometry = result;\n\n\t\t\t});\n\n\t\twhile (geometry === null) {\n\n\t\t\tyield;\n\n\t\t}\n\n\t}\n\n\tconst trimTime = window.performance.now() - timeStart;\n\n\tprojection.geometry.dispose();\n\tprojection.geometry = geometry;\n\toutputContainer.innerText =\n\t\t`merge geometry  : ${mergeTime.toFixed(2)}ms\\n` +\n\t\t`edge trimming   : ${trimTime.toFixed(2)}ms`;\n\n}\n\n\nfunction render() {\n\n\trequestAnimationFrame(render);\n\n\tif (task) {\n\n\t\tconst res = task.next();\n\t\tif (res.done) {\n\n\t\t\ttask = null;\n\n\t\t}\n\n\t}\n\n\tmodel.visible = params.displayModel === 'color';\n\tshadedWhiteModel.visible = params.displayModel === 'shaded white';\n\twhiteModel.visible = params.displayModel === 'white';\n\tlines.visible = params.displayEdges;\n\tprojection.visible = params.displayProjection;\n\n\trenderer.render(scene, camera);\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tLoader,\n\tLinearSRGBColorSpace,\n\tSRGBColorSpace\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.parse( buffer, onLoad, onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( buffer, onLoad, onError ) {\n\n\t\tthis.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs,\n\t\t\tvertexColorSpace: vertexColorSpace,\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst result = geometryData.attributes[ i ];\n\t\t\tconst name = result.name;\n\t\t\tconst array = result.array;\n\t\t\tconst itemSize = result.itemSize;\n\n\t\t\tconst attribute = new BufferAttribute( array, itemSize );\n\n\t\t\tif ( name === 'color' ) {\n\n\t\t\t\tthis._assignVertexColorSpace( attribute, result.vertexColorSpace );\n\n\t\t\t\tattribute.normalized = ( array instanceof Float32Array ) === false;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( name, attribute );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_assignVertexColorSpace( attribute, inputColorSpace ) {\n\n\t\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n\t\t// file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n\t\t// to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n\t\tif ( inputColorSpace !== SRGBColorSpace ) return;\n\n\t\tconst _color = new Color();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();\n\t\t\tattribute.setXYZ( i, _color.r, _color.g, _color.b );\n\n\t\t}\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\tif ( this.workerSourceURL !== '' ) {\n\n\t\t\tURL.revokeObjectURL( this.workerSourceURL );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, array, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( array );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tconst attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\n\n\t\t\tif ( attributeName === 'color' ) {\n\n\t\t\t\tattributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( attributeResult );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n","import { BufferAttribute, BufferGeometry } from 'three';\n\nconst NAME = 'ProjectionGeneratorWorker';\nexport class ProjectionGeneratorWorker {\n\n\tconstructor() {\n\n\t\tthis.running = false;\n\t\tthis.worker = new Worker( new URL( './projectionAsync.worker.js', import.meta.url ), { type: 'module' } );\n\t\tthis.worker.onerror = e => {\n\n\t\t\tif ( e.message ) {\n\n\t\t\t\tthrow new Error( `${ NAME }: Could not create Web Worker with error \"${ e.message }\"` );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( `${ NAME }: Could not create Web Worker.` );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tgenerate( geometry, options = {} ) {\n\n\t\tif ( this.running ) {\n\n\t\t\tthrow new Error( `${ NAME }: Already running job.` );\n\n\t\t}\n\n\t\tif ( this.worker === null ) {\n\n\t\t\tthrow new Error( `${ NAME }: Worker has been disposed.` );\n\n\t\t}\n\n\t\tconst { worker } = this;\n\t\tthis.running = true;\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tworker.onerror = e => {\n\n\t\t\t\treject( new Error( `${ NAME }: ${ e.message }` ) );\n\t\t\t\tthis.running = false;\n\n\t\t\t};\n\n\t\t\tworker.onmessage = e => {\n\n\t\t\t\tthis.running = false;\n\t\t\t\tconst { data } = e;\n\n\t\t\t\tif ( data.error ) {\n\n\t\t\t\t\treject( new Error( data.error ) );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( data.result ) {\n\n\t\t\t\t\tconst geometry = new BufferGeometry();\n\t\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( data.result, 3, false ) );\n\t\t\t\t\tresolve( geometry );\n\t\t\t\t\tworker.onmessage = null;\n\n\t\t\t\t} else if ( options.onProgress ) {\n\n\t\t\t\t\toptions.onProgress( data.progress );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index ? geometry.index.array.slice() : null;\n\t\t\tconst position = geometry.attributes.position.array.slice();\n\t\t\tconst transfer = [ position.buffer ];\n\t\t\tif ( index ) {\n\n\t\t\t\ttransfer.push( index.buffer );\n\n\t\t\t}\n\n\t\t\tworker.postMessage( {\n\t\t\t\tindex,\n\t\t\t\tposition,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tonProgress: null,\n\t\t\t\t\tincludedProgressCallback: Boolean( options.onProgress ),\n\t\t\t\t},\n\t\t\t}, transfer );\n\n\t\t} );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\n\t}\n\n}\n","let workerURL = require('./helpers/get-worker-url');\nlet url = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"8zbCD\"));\nmodule.exports = workerURL(url.toString(), url.origin, true);","\"use strict\";\n\nmodule.exports = function (workerUrl, origin, isESM) {\n  if (origin === self.location.origin) {\n    // If the worker bundle's url is on the same origin as the document,\n    // use the worker bundle's own url.\n    return workerUrl;\n  } else {\n    // Otherwise, create a blob URL which loads the worker bundle with `importScripts`.\n    var source = isESM ? 'import ' + JSON.stringify(workerUrl) + ';' : 'importScripts(' + JSON.stringify(workerUrl) + ');';\n    return URL.createObjectURL(new Blob([source], {\n      type: 'application/javascript'\n    }));\n  }\n};"],"names":["$c9fdec40e3bbb10a$var$renderer","$c9fdec40e3bbb10a$var$camera","$c9fdec40e3bbb10a$var$scene","$c9fdec40e3bbb10a$var$gui","$c9fdec40e3bbb10a$var$lines","$c9fdec40e3bbb10a$var$model","$c9fdec40e3bbb10a$var$projection","$c9fdec40e3bbb10a$var$group","$c9fdec40e3bbb10a$var$shadedWhiteModel","$c9fdec40e3bbb10a$var$whiteModel","$c9fdec40e3bbb10a$var$outputContainer","$c9fdec40e3bbb10a$var$worker","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","i","length","resolved","JSON","parse","$ilwiq","$jiuw3","$5Rd1x","$7lx9d","$8e8b252f320f3b48$var$_taskCache","WeakMap","$8e8b252f320f3b48$export$45c25de53be259ac","Loader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","decodeDracoFile","SRGBColorSpace","catch","callback","attributeIDs","attributeTypes","vertexColorSpace","LinearSRGBColorSpace","taskConfig","useUniqueIDs","decodeGeometry","then","worker","taskKey","stringify","has","cachedTask","key","promise","byteLength","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","message","_createGeometry","geometry","_releaseTask","geometryData","BufferGeometry","index","setIndex","BufferAttribute","array","attributes","result","name","itemSize","attribute","_assignVertexColorSpace","normalized","Float32Array","setAttribute","inputColorSpace","_color","Color","il","count","fromBufferAttribute","convertSRGBToLinear","setXYZ","r","g","b","_loadLibrary","responseType","undefined","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","$8e8b252f320f3b48$var$DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","data","console","error","sort","a","debug","log","map","dispose","terminate","revokeObjectURL","onModuleLoaded","draco","DracoDecoderModule","decoder","Decoder","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeArrayToMesh","POINT_CLOUD","PointCloud","DecodeArrayToPointCloud","ok","ptr","error_msg","attributeName","attributeID","attributeType","GetAttributeByUniqueId","GetAttributeId","GetAttribute","attributeResult","decodeAttribute","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","Uint32Array","DT_UINT32","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","slice","_free","decodeIndex","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","destroy","buffers","attr","$7ePFa","$kp7Te","$4CEV9","$5c260663d40074f0$var$NAME","$deac5b03489e8ef8$exports","$56b621a6dd25b2cb$exports","workerUrl","origin","isESM","location","source","$deac5b03489e8ef8$var$url","$5c260663d40074f0$export$58847e466a6b9214","running","onerror","generate","options","progress","transfer","includedProgressCallback","Boolean","$fNPnQ","Object3D","DEFAULT_UP","$c9fdec40e3bbb10a$var$params","displayModel","displayEdges","displayProjection","sortEdges","includeIntersectionEdges","useWorker","projectionDirection","rotate","quaternion","random","updateMatrixWorld","box","Box3","setFromObject","getCenter","multiplyScalar","y","Math","max","min","regenerate","$c9fdec40e3bbb10a$var$task","$c9fdec40e3bbb10a$var$updateEdges","runTime","innerText","timeStart","performance","now","geometries","updateWorldMatrix","traverse","c","clone","applyMatrix4","matrixWorld","morphTargetsRelative","morphAttributes","deleteAttribute","mergedGeometry","mergeGeometries","mergeTime","iterationTime","angleThreshold","p","parseFloat","toFixed","generator","ProjectionGenerator","task","getLineGeometry","next","done","value","trimTime","$c9fdec40e3bbb10a$var$init","document","getElementById","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","innerWidth","innerHeight","setClearColor","appendChild","domElement","Scene","light","DirectionalLight","add","ambientLight","AmbientLight","Group","gltfLoader","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","dr","setDRACOLoader","gltf","loadAsync","scene","whiteMaterial","MeshStandardMaterial","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","material","whiteBasicMaterial","MeshBasicMaterial","abs","z","edges","generateEdges","points","flatMap","line","start","end","geom","setFromPoints","geomLines","LineSegments","LineBasicMaterial","copy","scale","PerspectiveCamera","setScalar","updateProjectionMatrix","lookAt","OrbitControls","GUI","$c9fdec40e3bbb10a$var$render","requestAnimationFrame","res","visible","render","addEventListener","aspect"],"version":3,"file":"edgeProjection.59721e0c.js.map"}